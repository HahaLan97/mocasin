#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue May 30 17:17:04 2017 by generateDS.py version 2.26a.
#
# Command line options:
#   ('-o', 'platform.py')
#
# Command line arguments:
#   SlxPlatformDescriptor.xsd
#
# Command line:
#   /net/home/cmenard/.local/bin/generateDS -o "platform.py" SlxPlatformDescriptor.xsd
#
# Current working directory (os.getcwd()):
#   slx_platform_descriptor
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name, pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0, optional=0):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class VoltageDomainType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, switchTimeValue='0', switchTimeUnit='us', Voltage=None, VoltageInput=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.switchTimeValue = _cast(None, switchTimeValue)
        self.switchTimeUnit = _cast(None, switchTimeUnit)
        if Voltage is None:
            self.Voltage = []
        else:
            self.Voltage = Voltage
        if VoltageInput is None:
            self.VoltageInput = []
        else:
            self.VoltageInput = VoltageInput
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageDomainType.subclass:
            return VoltageDomainType.subclass(*args_, **kwargs_)
        else:
            return VoltageDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Voltage(self): return self.Voltage
    def set_Voltage(self, Voltage): self.Voltage = Voltage
    def add_Voltage(self, value): self.Voltage.append(value)
    def insert_Voltage_at(self, index, value): self.Voltage.insert(index, value)
    def replace_Voltage_at(self, index, value): self.Voltage[index] = value
    def get_VoltageInput(self): return self.VoltageInput
    def set_VoltageInput(self, VoltageInput): self.VoltageInput = VoltageInput
    def add_VoltageInput(self, value): self.VoltageInput.append(value)
    def insert_VoltageInput_at(self, index, value): self.VoltageInput.insert(index, value)
    def replace_VoltageInput_at(self, index, value): self.VoltageInput[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_switchTimeValue(self): return self.switchTimeValue
    def set_switchTimeValue(self, switchTimeValue): self.switchTimeValue = switchTimeValue
    def get_switchTimeUnit(self): return self.switchTimeUnit
    def set_switchTimeUnit(self, switchTimeUnit): self.switchTimeUnit = switchTimeUnit
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_TimeValueType(self, value):
        # Validate type TimeValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on TimeValueType' % {"value" : value} )
    def validate_TimeUnitType(self, value):
        # Validate type TimeUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ps', 'ns', 'us', 'ms', 's']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TimeUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Voltage or
            self.VoltageInput
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='VoltageDomainType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageDomainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='VoltageDomainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='VoltageDomainType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.switchTimeValue != "0" and 'switchTimeValue' not in already_processed:
            already_processed.add('switchTimeValue')
            outfile.write(' switchTimeValue=%s' % (quote_attrib(self.switchTimeValue), ))
        if self.switchTimeUnit != "us" and 'switchTimeUnit' not in already_processed:
            already_processed.add('switchTimeUnit')
            outfile.write(' switchTimeUnit=%s' % (quote_attrib(self.switchTimeUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='VoltageDomainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Voltage_ in self.Voltage:
            Voltage_.export(outfile, level, namespace_, name_='Voltage', pretty_print=pretty_print)
        for VoltageInput_ in self.VoltageInput:
            VoltageInput_.export(outfile, level, namespace_, name_='VoltageInput', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('switchTimeValue', node)
        if value is not None and 'switchTimeValue' not in already_processed:
            already_processed.add('switchTimeValue')
            self.switchTimeValue = value
            self.validate_TimeValueType(self.switchTimeValue)    # validate type TimeValueType
        value = find_attr_value_('switchTimeUnit', node)
        if value is not None and 'switchTimeUnit' not in already_processed:
            already_processed.add('switchTimeUnit')
            self.switchTimeUnit = value
            self.validate_TimeUnitType(self.switchTimeUnit)    # validate type TimeUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Voltage':
            obj_ = VoltageType.factory()
            obj_.build(child_)
            self.Voltage.append(obj_)
            obj_.original_tagname_ = 'Voltage'
        elif nodeName_ == 'VoltageInput':
            obj_ = VoltageInputType.factory()
            obj_.build(child_)
            self.VoltageInput.append(obj_)
            obj_.original_tagname_ = 'VoltageInput'
# end class VoltageDomainType


class FrequencyDomainType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, switchTimeValue='0', switchTimeUnit='us', Frequency=None, FrequencyInput=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.switchTimeValue = _cast(None, switchTimeValue)
        self.switchTimeUnit = _cast(None, switchTimeUnit)
        if Frequency is None:
            self.Frequency = []
        else:
            self.Frequency = Frequency
        if FrequencyInput is None:
            self.FrequencyInput = []
        else:
            self.FrequencyInput = FrequencyInput
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyDomainType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyDomainType.subclass:
            return FrequencyDomainType.subclass(*args_, **kwargs_)
        else:
            return FrequencyDomainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    def add_Frequency(self, value): self.Frequency.append(value)
    def insert_Frequency_at(self, index, value): self.Frequency.insert(index, value)
    def replace_Frequency_at(self, index, value): self.Frequency[index] = value
    def get_FrequencyInput(self): return self.FrequencyInput
    def set_FrequencyInput(self, FrequencyInput): self.FrequencyInput = FrequencyInput
    def add_FrequencyInput(self, value): self.FrequencyInput.append(value)
    def insert_FrequencyInput_at(self, index, value): self.FrequencyInput.insert(index, value)
    def replace_FrequencyInput_at(self, index, value): self.FrequencyInput[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_switchTimeValue(self): return self.switchTimeValue
    def set_switchTimeValue(self, switchTimeValue): self.switchTimeValue = switchTimeValue
    def get_switchTimeUnit(self): return self.switchTimeUnit
    def set_switchTimeUnit(self, switchTimeUnit): self.switchTimeUnit = switchTimeUnit
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_TimeValueType(self, value):
        # Validate type TimeValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on TimeValueType' % {"value" : value} )
    def validate_TimeUnitType(self, value):
        # Validate type TimeUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ps', 'ns', 'us', 'ms', 's']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TimeUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Frequency or
            self.FrequencyInput
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FrequencyDomainType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyDomainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FrequencyDomainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FrequencyDomainType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.switchTimeValue != "0" and 'switchTimeValue' not in already_processed:
            already_processed.add('switchTimeValue')
            outfile.write(' switchTimeValue=%s' % (quote_attrib(self.switchTimeValue), ))
        if self.switchTimeUnit != "us" and 'switchTimeUnit' not in already_processed:
            already_processed.add('switchTimeUnit')
            outfile.write(' switchTimeUnit=%s' % (quote_attrib(self.switchTimeUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FrequencyDomainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Frequency_ in self.Frequency:
            Frequency_.export(outfile, level, namespace_, name_='Frequency', pretty_print=pretty_print)
        for FrequencyInput_ in self.FrequencyInput:
            FrequencyInput_.export(outfile, level, namespace_, name_='FrequencyInput', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('switchTimeValue', node)
        if value is not None and 'switchTimeValue' not in already_processed:
            already_processed.add('switchTimeValue')
            self.switchTimeValue = value
            self.validate_TimeValueType(self.switchTimeValue)    # validate type TimeValueType
        value = find_attr_value_('switchTimeUnit', node)
        if value is not None and 'switchTimeUnit' not in already_processed:
            already_processed.add('switchTimeUnit')
            self.switchTimeUnit = value
            self.validate_TimeUnitType(self.switchTimeUnit)    # validate type TimeUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Frequency':
            obj_ = FrequencyType.factory()
            obj_.build(child_)
            self.Frequency.append(obj_)
            obj_.original_tagname_ = 'Frequency'
        elif nodeName_ == 'FrequencyInput':
            obj_ = FrequencyInputType.factory()
            obj_.build(child_)
            self.FrequencyInput.append(obj_)
            obj_.original_tagname_ = 'FrequencyInput'
# end class FrequencyDomainType


class VoltageDomainConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, voltageDomain=None, condition=None, value=None, unit=None):
        self.original_tagname_ = None
        self.voltageDomain = _cast(None, voltageDomain)
        self.condition = _cast(None, condition)
        self.value = _cast(None, value)
        self.unit = _cast(None, unit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageDomainConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageDomainConditionType.subclass:
            return VoltageDomainConditionType.subclass(*args_, **kwargs_)
        else:
            return VoltageDomainConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_voltageDomain(self): return self.voltageDomain
    def set_voltageDomain(self, voltageDomain): self.voltageDomain = voltageDomain
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_MinMaxEqualType(self, value):
        # Validate type MinMaxEqualType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['min', 'max', 'equal']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MinMaxEqualType' % {"value" : value.encode("utf-8")} )
    def validate_VoltageValueType(self, value):
        # Validate type VoltageValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on VoltageValueType' % {"value" : value} )
    def validate_VoltageUnitType(self, value):
        # Validate type VoltageUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['mV', 'V']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoltageUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='VoltageDomainConditionType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageDomainConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='VoltageDomainConditionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='VoltageDomainConditionType'):
        if self.voltageDomain is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            outfile.write(' voltageDomain=%s' % (quote_attrib(self.voltageDomain), ))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            outfile.write(' condition=%s' % (quote_attrib(self.condition), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='VoltageDomainConditionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('voltageDomain', node)
        if value is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            self.voltageDomain = value
            self.validate_RefType(self.voltageDomain)    # validate type RefType
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            self.condition = value
            self.validate_MinMaxEqualType(self.condition)    # validate type MinMaxEqualType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_VoltageValueType(self.value)    # validate type VoltageValueType
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_VoltageUnitType(self.unit)    # validate type VoltageUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VoltageDomainConditionType


class FrequencyDomainConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequencyDomain=None, condition=None, value=None, unit=None):
        self.original_tagname_ = None
        self.frequencyDomain = _cast(None, frequencyDomain)
        self.condition = _cast(None, condition)
        self.value = _cast(None, value)
        self.unit = _cast(None, unit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyDomainConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyDomainConditionType.subclass:
            return FrequencyDomainConditionType.subclass(*args_, **kwargs_)
        else:
            return FrequencyDomainConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frequencyDomain(self): return self.frequencyDomain
    def set_frequencyDomain(self, frequencyDomain): self.frequencyDomain = frequencyDomain
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_MinMaxEqualType(self, value):
        # Validate type MinMaxEqualType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['min', 'max', 'equal']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MinMaxEqualType' % {"value" : value.encode("utf-8")} )
    def validate_FrequencyValueType(self, value):
        # Validate type FrequencyValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FrequencyValueType' % {"value" : value} )
    def validate_FrequencyUnitType(self, value):
        # Validate type FrequencyUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Hz', 'kHz', 'MHz', 'GHz']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FrequencyUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FrequencyDomainConditionType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyDomainConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FrequencyDomainConditionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FrequencyDomainConditionType'):
        if self.frequencyDomain is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            outfile.write(' frequencyDomain=%s' % (quote_attrib(self.frequencyDomain), ))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            outfile.write(' condition=%s' % (quote_attrib(self.condition), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FrequencyDomainConditionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequencyDomain', node)
        if value is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            self.frequencyDomain = value
            self.validate_RefType(self.frequencyDomain)    # validate type RefType
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            self.condition = value
            self.validate_MinMaxEqualType(self.condition)    # validate type MinMaxEqualType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_FrequencyValueType(self.value)    # validate type FrequencyValueType
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_FrequencyUnitType(self.unit)    # validate type FrequencyUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrequencyDomainConditionType


class VoltageFrequencyDomainConditionListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VoltageDomainCondition=None, FrequencyDomainCondition=None, extensiontype_=None):
        self.original_tagname_ = None
        if VoltageDomainCondition is None:
            self.VoltageDomainCondition = []
        else:
            self.VoltageDomainCondition = VoltageDomainCondition
        if FrequencyDomainCondition is None:
            self.FrequencyDomainCondition = []
        else:
            self.FrequencyDomainCondition = FrequencyDomainCondition
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageFrequencyDomainConditionListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageFrequencyDomainConditionListType.subclass:
            return VoltageFrequencyDomainConditionListType.subclass(*args_, **kwargs_)
        else:
            return VoltageFrequencyDomainConditionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VoltageDomainCondition(self): return self.VoltageDomainCondition
    def set_VoltageDomainCondition(self, VoltageDomainCondition): self.VoltageDomainCondition = VoltageDomainCondition
    def add_VoltageDomainCondition(self, value): self.VoltageDomainCondition.append(value)
    def insert_VoltageDomainCondition_at(self, index, value): self.VoltageDomainCondition.insert(index, value)
    def replace_VoltageDomainCondition_at(self, index, value): self.VoltageDomainCondition[index] = value
    def get_FrequencyDomainCondition(self): return self.FrequencyDomainCondition
    def set_FrequencyDomainCondition(self, FrequencyDomainCondition): self.FrequencyDomainCondition = FrequencyDomainCondition
    def add_FrequencyDomainCondition(self, value): self.FrequencyDomainCondition.append(value)
    def insert_FrequencyDomainCondition_at(self, index, value): self.FrequencyDomainCondition.insert(index, value)
    def replace_FrequencyDomainCondition_at(self, index, value): self.FrequencyDomainCondition[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.VoltageDomainCondition or
            self.FrequencyDomainCondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='VoltageFrequencyDomainConditionListType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageFrequencyDomainConditionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='VoltageFrequencyDomainConditionListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='VoltageFrequencyDomainConditionListType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='VoltageFrequencyDomainConditionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VoltageDomainCondition_ in self.VoltageDomainCondition:
            VoltageDomainCondition_.export(outfile, level, namespace_, name_='VoltageDomainCondition', pretty_print=pretty_print)
        for FrequencyDomainCondition_ in self.FrequencyDomainCondition:
            FrequencyDomainCondition_.export(outfile, level, namespace_, name_='FrequencyDomainCondition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VoltageDomainCondition':
            obj_ = VoltageDomainConditionType.factory()
            obj_.build(child_)
            self.VoltageDomainCondition.append(obj_)
            obj_.original_tagname_ = 'VoltageDomainCondition'
        elif nodeName_ == 'FrequencyDomainCondition':
            obj_ = FrequencyDomainConditionType.factory()
            obj_.build(child_)
            self.FrequencyDomainCondition.append(obj_)
            obj_.original_tagname_ = 'FrequencyDomainCondition'
# end class VoltageFrequencyDomainConditionListType


class VoltageConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, condition=None, value=None, unit=None):
        self.original_tagname_ = None
        self.condition = _cast(None, condition)
        self.value = _cast(None, value)
        self.unit = _cast(None, unit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageConditionType.subclass:
            return VoltageConditionType.subclass(*args_, **kwargs_)
        else:
            return VoltageConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def validate_MinMaxEqualType(self, value):
        # Validate type MinMaxEqualType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['min', 'max', 'equal']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MinMaxEqualType' % {"value" : value.encode("utf-8")} )
    def validate_VoltageValueType(self, value):
        # Validate type VoltageValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on VoltageValueType' % {"value" : value} )
    def validate_VoltageUnitType(self, value):
        # Validate type VoltageUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['mV', 'V']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoltageUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='VoltageConditionType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='VoltageConditionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='VoltageConditionType'):
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            outfile.write(' condition=%s' % (quote_attrib(self.condition), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='VoltageConditionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            self.condition = value
            self.validate_MinMaxEqualType(self.condition)    # validate type MinMaxEqualType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_VoltageValueType(self.value)    # validate type VoltageValueType
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_VoltageUnitType(self.unit)    # validate type VoltageUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VoltageConditionType


class FrequencyConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, condition=None, value=None, unit=None):
        self.original_tagname_ = None
        self.condition = _cast(None, condition)
        self.value = _cast(None, value)
        self.unit = _cast(None, unit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyConditionType.subclass:
            return FrequencyConditionType.subclass(*args_, **kwargs_)
        else:
            return FrequencyConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def validate_MinMaxEqualType(self, value):
        # Validate type MinMaxEqualType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['min', 'max', 'equal']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MinMaxEqualType' % {"value" : value.encode("utf-8")} )
    def validate_FrequencyValueType(self, value):
        # Validate type FrequencyValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FrequencyValueType' % {"value" : value} )
    def validate_FrequencyUnitType(self, value):
        # Validate type FrequencyUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Hz', 'kHz', 'MHz', 'GHz']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FrequencyUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FrequencyConditionType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FrequencyConditionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FrequencyConditionType'):
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            outfile.write(' condition=%s' % (quote_attrib(self.condition), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FrequencyConditionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.add('condition')
            self.condition = value
            self.validate_MinMaxEqualType(self.condition)    # validate type MinMaxEqualType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_FrequencyValueType(self.value)    # validate type FrequencyValueType
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_FrequencyUnitType(self.unit)    # validate type FrequencyUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrequencyConditionType


class FrequencyVoltageConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequencyValue=None, frequencyUnit=None, voltageValue=None, voltageUnit=None):
        self.original_tagname_ = None
        self.frequencyValue = _cast(None, frequencyValue)
        self.frequencyUnit = _cast(None, frequencyUnit)
        self.voltageValue = _cast(None, voltageValue)
        self.voltageUnit = _cast(None, voltageUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyVoltageConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyVoltageConditionType.subclass:
            return FrequencyVoltageConditionType.subclass(*args_, **kwargs_)
        else:
            return FrequencyVoltageConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frequencyValue(self): return self.frequencyValue
    def set_frequencyValue(self, frequencyValue): self.frequencyValue = frequencyValue
    def get_frequencyUnit(self): return self.frequencyUnit
    def set_frequencyUnit(self, frequencyUnit): self.frequencyUnit = frequencyUnit
    def get_voltageValue(self): return self.voltageValue
    def set_voltageValue(self, voltageValue): self.voltageValue = voltageValue
    def get_voltageUnit(self): return self.voltageUnit
    def set_voltageUnit(self, voltageUnit): self.voltageUnit = voltageUnit
    def validate_FrequencyValueType(self, value):
        # Validate type FrequencyValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FrequencyValueType' % {"value" : value} )
    def validate_FrequencyUnitType(self, value):
        # Validate type FrequencyUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Hz', 'kHz', 'MHz', 'GHz']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FrequencyUnitType' % {"value" : value.encode("utf-8")} )
    def validate_VoltageValueType(self, value):
        # Validate type VoltageValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on VoltageValueType' % {"value" : value} )
    def validate_VoltageUnitType(self, value):
        # Validate type VoltageUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['mV', 'V']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoltageUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FrequencyVoltageConditionType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyVoltageConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FrequencyVoltageConditionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FrequencyVoltageConditionType'):
        if self.frequencyValue is not None and 'frequencyValue' not in already_processed:
            already_processed.add('frequencyValue')
            outfile.write(' frequencyValue=%s' % (quote_attrib(self.frequencyValue), ))
        if self.frequencyUnit is not None and 'frequencyUnit' not in already_processed:
            already_processed.add('frequencyUnit')
            outfile.write(' frequencyUnit=%s' % (quote_attrib(self.frequencyUnit), ))
        if self.voltageValue is not None and 'voltageValue' not in already_processed:
            already_processed.add('voltageValue')
            outfile.write(' voltageValue=%s' % (quote_attrib(self.voltageValue), ))
        if self.voltageUnit is not None and 'voltageUnit' not in already_processed:
            already_processed.add('voltageUnit')
            outfile.write(' voltageUnit=%s' % (quote_attrib(self.voltageUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FrequencyVoltageConditionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequencyValue', node)
        if value is not None and 'frequencyValue' not in already_processed:
            already_processed.add('frequencyValue')
            self.frequencyValue = value
            self.validate_FrequencyValueType(self.frequencyValue)    # validate type FrequencyValueType
        value = find_attr_value_('frequencyUnit', node)
        if value is not None and 'frequencyUnit' not in already_processed:
            already_processed.add('frequencyUnit')
            self.frequencyUnit = value
            self.validate_FrequencyUnitType(self.frequencyUnit)    # validate type FrequencyUnitType
        value = find_attr_value_('voltageValue', node)
        if value is not None and 'voltageValue' not in already_processed:
            already_processed.add('voltageValue')
            self.voltageValue = value
            self.validate_VoltageValueType(self.voltageValue)    # validate type VoltageValueType
        value = find_attr_value_('voltageUnit', node)
        if value is not None and 'voltageUnit' not in already_processed:
            already_processed.add('voltageUnit')
            self.voltageUnit = value
            self.validate_VoltageUnitType(self.voltageUnit)    # validate type VoltageUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrequencyVoltageConditionType


class VoltageFrequencyConditionListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VoltageCondition=None, FrequencyCondition=None, FrequencyVoltageCondition=None, extensiontype_=None):
        self.original_tagname_ = None
        if VoltageCondition is None:
            self.VoltageCondition = []
        else:
            self.VoltageCondition = VoltageCondition
        if FrequencyCondition is None:
            self.FrequencyCondition = []
        else:
            self.FrequencyCondition = FrequencyCondition
        if FrequencyVoltageCondition is None:
            self.FrequencyVoltageCondition = []
        else:
            self.FrequencyVoltageCondition = FrequencyVoltageCondition
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageFrequencyConditionListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageFrequencyConditionListType.subclass:
            return VoltageFrequencyConditionListType.subclass(*args_, **kwargs_)
        else:
            return VoltageFrequencyConditionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VoltageCondition(self): return self.VoltageCondition
    def set_VoltageCondition(self, VoltageCondition): self.VoltageCondition = VoltageCondition
    def add_VoltageCondition(self, value): self.VoltageCondition.append(value)
    def insert_VoltageCondition_at(self, index, value): self.VoltageCondition.insert(index, value)
    def replace_VoltageCondition_at(self, index, value): self.VoltageCondition[index] = value
    def get_FrequencyCondition(self): return self.FrequencyCondition
    def set_FrequencyCondition(self, FrequencyCondition): self.FrequencyCondition = FrequencyCondition
    def add_FrequencyCondition(self, value): self.FrequencyCondition.append(value)
    def insert_FrequencyCondition_at(self, index, value): self.FrequencyCondition.insert(index, value)
    def replace_FrequencyCondition_at(self, index, value): self.FrequencyCondition[index] = value
    def get_FrequencyVoltageCondition(self): return self.FrequencyVoltageCondition
    def set_FrequencyVoltageCondition(self, FrequencyVoltageCondition): self.FrequencyVoltageCondition = FrequencyVoltageCondition
    def add_FrequencyVoltageCondition(self, value): self.FrequencyVoltageCondition.append(value)
    def insert_FrequencyVoltageCondition_at(self, index, value): self.FrequencyVoltageCondition.insert(index, value)
    def replace_FrequencyVoltageCondition_at(self, index, value): self.FrequencyVoltageCondition[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.VoltageCondition or
            self.FrequencyCondition or
            self.FrequencyVoltageCondition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='VoltageFrequencyConditionListType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageFrequencyConditionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='VoltageFrequencyConditionListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='VoltageFrequencyConditionListType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='VoltageFrequencyConditionListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VoltageCondition_ in self.VoltageCondition:
            VoltageCondition_.export(outfile, level, namespace_, name_='VoltageCondition', pretty_print=pretty_print)
        for FrequencyCondition_ in self.FrequencyCondition:
            FrequencyCondition_.export(outfile, level, namespace_, name_='FrequencyCondition', pretty_print=pretty_print)
        for FrequencyVoltageCondition_ in self.FrequencyVoltageCondition:
            FrequencyVoltageCondition_.export(outfile, level, namespace_, name_='FrequencyVoltageCondition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VoltageCondition':
            obj_ = VoltageConditionType.factory()
            obj_.build(child_)
            self.VoltageCondition.append(obj_)
            obj_.original_tagname_ = 'VoltageCondition'
        elif nodeName_ == 'FrequencyCondition':
            obj_ = FrequencyConditionType.factory()
            obj_.build(child_)
            self.FrequencyCondition.append(obj_)
            obj_.original_tagname_ = 'FrequencyCondition'
        elif nodeName_ == 'FrequencyVoltageCondition':
            obj_ = FrequencyVoltageConditionType.factory()
            obj_.build(child_)
            self.FrequencyVoltageCondition.append(obj_)
            obj_.original_tagname_ = 'FrequencyVoltageCondition'
# end class VoltageFrequencyConditionListType


class SchedulingPolicyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, schedulingAlgorithm=None, timeSliceValue=None, timeSliceUnit='s'):
        self.original_tagname_ = None
        self.schedulingAlgorithm = _cast(None, schedulingAlgorithm)
        self.timeSliceValue = _cast(None, timeSliceValue)
        self.timeSliceUnit = _cast(None, timeSliceUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulingPolicyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulingPolicyType.subclass:
            return SchedulingPolicyType.subclass(*args_, **kwargs_)
        else:
            return SchedulingPolicyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_schedulingAlgorithm(self): return self.schedulingAlgorithm
    def set_schedulingAlgorithm(self, schedulingAlgorithm): self.schedulingAlgorithm = schedulingAlgorithm
    def get_timeSliceValue(self): return self.timeSliceValue
    def set_timeSliceValue(self, timeSliceValue): self.timeSliceValue = timeSliceValue
    def get_timeSliceUnit(self): return self.timeSliceUnit
    def set_timeSliceUnit(self, timeSliceUnit): self.timeSliceUnit = timeSliceUnit
    def validate_SchedulingAlgorithmType(self, value):
        # Validate type SchedulingAlgorithmType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_SchedulingAlgorithmType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_SchedulingAlgorithmType_patterns_, ))
    validate_SchedulingAlgorithmType_patterns_ = [['^FIFO$', '^Priority$', '^RoundRobin$', '^[a-zA-Z0-9_]+[.][a-zA-Z0-9_]+$']]
    def validate_TimeValueType(self, value):
        # Validate type TimeValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on TimeValueType' % {"value" : value} )
    def validate_TimeUnitType(self, value):
        # Validate type TimeUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ps', 'ns', 'us', 'ms', 's']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TimeUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='SchedulingPolicyType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SchedulingPolicyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='SchedulingPolicyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='SchedulingPolicyType'):
        if self.schedulingAlgorithm is not None and 'schedulingAlgorithm' not in already_processed:
            already_processed.add('schedulingAlgorithm')
            outfile.write(' schedulingAlgorithm=%s' % (quote_attrib(self.schedulingAlgorithm), ))
        if self.timeSliceValue is not None and 'timeSliceValue' not in already_processed:
            already_processed.add('timeSliceValue')
            outfile.write(' timeSliceValue=%s' % (quote_attrib(self.timeSliceValue), ))
        if self.timeSliceUnit != "s" and 'timeSliceUnit' not in already_processed:
            already_processed.add('timeSliceUnit')
            outfile.write(' timeSliceUnit=%s' % (quote_attrib(self.timeSliceUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='SchedulingPolicyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schedulingAlgorithm', node)
        if value is not None and 'schedulingAlgorithm' not in already_processed:
            already_processed.add('schedulingAlgorithm')
            self.schedulingAlgorithm = value
            self.validate_SchedulingAlgorithmType(self.schedulingAlgorithm)    # validate type SchedulingAlgorithmType
        value = find_attr_value_('timeSliceValue', node)
        if value is not None and 'timeSliceValue' not in already_processed:
            already_processed.add('timeSliceValue')
            self.timeSliceValue = value
            self.validate_TimeValueType(self.timeSliceValue)    # validate type TimeValueType
        value = find_attr_value_('timeSliceUnit', node)
        if value is not None and 'timeSliceUnit' not in already_processed:
            already_processed.add('timeSliceUnit')
            self.timeSliceUnit = value
            self.validate_TimeUnitType(self.timeSliceUnit)    # validate type TimeUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SchedulingPolicyType


class SchedulingPolicyListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, SchedulingPolicy=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if SchedulingPolicy is None:
            self.SchedulingPolicy = []
        else:
            self.SchedulingPolicy = SchedulingPolicy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulingPolicyListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulingPolicyListType.subclass:
            return SchedulingPolicyListType.subclass(*args_, **kwargs_)
        else:
            return SchedulingPolicyListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SchedulingPolicy(self): return self.SchedulingPolicy
    def set_SchedulingPolicy(self, SchedulingPolicy): self.SchedulingPolicy = SchedulingPolicy
    def add_SchedulingPolicy(self, value): self.SchedulingPolicy.append(value)
    def insert_SchedulingPolicy_at(self, index, value): self.SchedulingPolicy.insert(index, value)
    def replace_SchedulingPolicy_at(self, index, value): self.SchedulingPolicy[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (
            self.SchedulingPolicy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='SchedulingPolicyListType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SchedulingPolicyListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='SchedulingPolicyListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='SchedulingPolicyListType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='SchedulingPolicyListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SchedulingPolicy_ in self.SchedulingPolicy:
            SchedulingPolicy_.export(outfile, level, namespace_, name_='SchedulingPolicy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SchedulingPolicy':
            obj_ = SchedulingPolicyType.factory()
            obj_.build(child_)
            self.SchedulingPolicy.append(obj_)
            obj_.original_tagname_ = 'SchedulingPolicy'
# end class SchedulingPolicyListType


class SchedulerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, schedulingPolicyList=None, maxTasks=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.schedulingPolicyList = _cast(None, schedulingPolicyList)
        self.maxTasks = _cast(None, maxTasks)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulerType.subclass:
            return SchedulerType.subclass(*args_, **kwargs_)
        else:
            return SchedulerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_schedulingPolicyList(self): return self.schedulingPolicyList
    def set_schedulingPolicyList(self, schedulingPolicyList): self.schedulingPolicyList = schedulingPolicyList
    def get_maxTasks(self): return self.maxTasks
    def set_maxTasks(self, maxTasks): self.maxTasks = maxTasks
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_PositiveIntType(self, value):
        # Validate type PositiveIntType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='SchedulerType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SchedulerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='SchedulerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='SchedulerType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.schedulingPolicyList is not None and 'schedulingPolicyList' not in already_processed:
            already_processed.add('schedulingPolicyList')
            outfile.write(' schedulingPolicyList=%s' % (quote_attrib(self.schedulingPolicyList), ))
        if self.maxTasks is not None and 'maxTasks' not in already_processed:
            already_processed.add('maxTasks')
            outfile.write(' maxTasks=%s' % (quote_attrib(self.maxTasks), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='SchedulerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('schedulingPolicyList', node)
        if value is not None and 'schedulingPolicyList' not in already_processed:
            already_processed.add('schedulingPolicyList')
            self.schedulingPolicyList = value
            self.validate_RefType(self.schedulingPolicyList)    # validate type RefType
        value = find_attr_value_('maxTasks', node)
        if value is not None and 'maxTasks' not in already_processed:
            already_processed.add('maxTasks')
            try:
                self.maxTasks = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.maxTasks <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveIntType(self.maxTasks)    # validate type PositiveIntType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SchedulerType


class ProcessorPowerStateType(VoltageFrequencyConditionListType):
    subclass = None
    superclass = VoltageFrequencyConditionListType
    def __init__(self, VoltageCondition=None, FrequencyCondition=None, FrequencyVoltageCondition=None, name=None, powerValue=None, powerUnit='pW'):
        self.original_tagname_ = None
        super(ProcessorPowerStateType, self).__init__(VoltageCondition, FrequencyCondition, FrequencyVoltageCondition, )
        self.name = _cast(None, name)
        self.powerValue = _cast(None, powerValue)
        self.powerUnit = _cast(None, powerUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessorPowerStateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessorPowerStateType.subclass:
            return ProcessorPowerStateType.subclass(*args_, **kwargs_)
        else:
            return ProcessorPowerStateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_powerValue(self): return self.powerValue
    def set_powerValue(self, powerValue): self.powerValue = powerValue
    def get_powerUnit(self): return self.powerUnit
    def set_powerUnit(self, powerUnit): self.powerUnit = powerUnit
    def validate_NameType(self, value):
        # Validate type NameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NameType_patterns_, ))
    validate_NameType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_PowerValueType(self, value):
        # Validate type PowerValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PowerValueType' % {"value" : value} )
    def validate_PowerUnitType(self, value):
        # Validate type PowerUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pW', 'nW', 'uW', 'mW', 'W']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PowerUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(ProcessorPowerStateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='ProcessorPowerStateType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessorPowerStateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='ProcessorPowerStateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='ProcessorPowerStateType'):
        super(ProcessorPowerStateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessorPowerStateType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.powerValue is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            outfile.write(' powerValue=%s' % (quote_attrib(self.powerValue), ))
        if self.powerUnit != "pW" and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            outfile.write(' powerUnit=%s' % (quote_attrib(self.powerUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='ProcessorPowerStateType', fromsubclass_=False, pretty_print=True):
        super(ProcessorPowerStateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NameType(self.name)    # validate type NameType
        value = find_attr_value_('powerValue', node)
        if value is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            self.powerValue = value
            self.validate_PowerValueType(self.powerValue)    # validate type PowerValueType
        value = find_attr_value_('powerUnit', node)
        if value is not None and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            self.powerUnit = value
            self.validate_PowerUnitType(self.powerUnit)    # validate type PowerUnitType
        super(ProcessorPowerStateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProcessorPowerStateType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProcessorPowerStateType


class ProcessorPowerModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, leakageCurrentValue='0', leakageCurrentUnit='pA', switchedCapacitanceValue='0', switchedCapacitanceUnit='pF', switchedCapacitanceIntAluValue='0', switchedCapacitanceIntAluUnit='pF', switchedCapacitanceIntMulValue='0', switchedCapacitanceIntMulUnit='pF', switchedCapacitanceIntDivValue='0', switchedCapacitanceIntDivUnit='pF', switchedCapacitanceFloatArithValue='0', switchedCapacitanceFloatArithUnit='pF', switchedCapacitanceFloatCompValue='0', switchedCapacitanceFloatCompUnit='pF', switchedCapacitanceFloatMulValue='0', switchedCapacitanceFloatMulUnit='pF', switchedCapacitanceFloatDivValue='0', switchedCapacitanceFloatDivUnit='pF', switchedCapacitanceLoadValue='0', switchedCapacitanceLoadUnit='pF', switchedCapacitanceStoreValue='0', switchedCapacitanceStoreUnit='pF', switchedCapacitanceControlValue='0', switchedCapacitanceControlUnit='pF', switchedCapacitanceOtherValue='0', switchedCapacitanceOtherUnit='pF', ProcessorPowerState=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.leakageCurrentValue = _cast(None, leakageCurrentValue)
        self.leakageCurrentUnit = _cast(None, leakageCurrentUnit)
        self.switchedCapacitanceValue = _cast(None, switchedCapacitanceValue)
        self.switchedCapacitanceUnit = _cast(None, switchedCapacitanceUnit)
        self.switchedCapacitanceIntAluValue = _cast(None, switchedCapacitanceIntAluValue)
        self.switchedCapacitanceIntAluUnit = _cast(None, switchedCapacitanceIntAluUnit)
        self.switchedCapacitanceIntMulValue = _cast(None, switchedCapacitanceIntMulValue)
        self.switchedCapacitanceIntMulUnit = _cast(None, switchedCapacitanceIntMulUnit)
        self.switchedCapacitanceIntDivValue = _cast(None, switchedCapacitanceIntDivValue)
        self.switchedCapacitanceIntDivUnit = _cast(None, switchedCapacitanceIntDivUnit)
        self.switchedCapacitanceFloatArithValue = _cast(None, switchedCapacitanceFloatArithValue)
        self.switchedCapacitanceFloatArithUnit = _cast(None, switchedCapacitanceFloatArithUnit)
        self.switchedCapacitanceFloatCompValue = _cast(None, switchedCapacitanceFloatCompValue)
        self.switchedCapacitanceFloatCompUnit = _cast(None, switchedCapacitanceFloatCompUnit)
        self.switchedCapacitanceFloatMulValue = _cast(None, switchedCapacitanceFloatMulValue)
        self.switchedCapacitanceFloatMulUnit = _cast(None, switchedCapacitanceFloatMulUnit)
        self.switchedCapacitanceFloatDivValue = _cast(None, switchedCapacitanceFloatDivValue)
        self.switchedCapacitanceFloatDivUnit = _cast(None, switchedCapacitanceFloatDivUnit)
        self.switchedCapacitanceLoadValue = _cast(None, switchedCapacitanceLoadValue)
        self.switchedCapacitanceLoadUnit = _cast(None, switchedCapacitanceLoadUnit)
        self.switchedCapacitanceStoreValue = _cast(None, switchedCapacitanceStoreValue)
        self.switchedCapacitanceStoreUnit = _cast(None, switchedCapacitanceStoreUnit)
        self.switchedCapacitanceControlValue = _cast(None, switchedCapacitanceControlValue)
        self.switchedCapacitanceControlUnit = _cast(None, switchedCapacitanceControlUnit)
        self.switchedCapacitanceOtherValue = _cast(None, switchedCapacitanceOtherValue)
        self.switchedCapacitanceOtherUnit = _cast(None, switchedCapacitanceOtherUnit)
        if ProcessorPowerState is None:
            self.ProcessorPowerState = []
        else:
            self.ProcessorPowerState = ProcessorPowerState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessorPowerModelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessorPowerModelType.subclass:
            return ProcessorPowerModelType.subclass(*args_, **kwargs_)
        else:
            return ProcessorPowerModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProcessorPowerState(self): return self.ProcessorPowerState
    def set_ProcessorPowerState(self, ProcessorPowerState): self.ProcessorPowerState = ProcessorPowerState
    def add_ProcessorPowerState(self, value): self.ProcessorPowerState.append(value)
    def insert_ProcessorPowerState_at(self, index, value): self.ProcessorPowerState.insert(index, value)
    def replace_ProcessorPowerState_at(self, index, value): self.ProcessorPowerState[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_leakageCurrentValue(self): return self.leakageCurrentValue
    def set_leakageCurrentValue(self, leakageCurrentValue): self.leakageCurrentValue = leakageCurrentValue
    def get_leakageCurrentUnit(self): return self.leakageCurrentUnit
    def set_leakageCurrentUnit(self, leakageCurrentUnit): self.leakageCurrentUnit = leakageCurrentUnit
    def get_switchedCapacitanceValue(self): return self.switchedCapacitanceValue
    def set_switchedCapacitanceValue(self, switchedCapacitanceValue): self.switchedCapacitanceValue = switchedCapacitanceValue
    def get_switchedCapacitanceUnit(self): return self.switchedCapacitanceUnit
    def set_switchedCapacitanceUnit(self, switchedCapacitanceUnit): self.switchedCapacitanceUnit = switchedCapacitanceUnit
    def get_switchedCapacitanceIntAluValue(self): return self.switchedCapacitanceIntAluValue
    def set_switchedCapacitanceIntAluValue(self, switchedCapacitanceIntAluValue): self.switchedCapacitanceIntAluValue = switchedCapacitanceIntAluValue
    def get_switchedCapacitanceIntAluUnit(self): return self.switchedCapacitanceIntAluUnit
    def set_switchedCapacitanceIntAluUnit(self, switchedCapacitanceIntAluUnit): self.switchedCapacitanceIntAluUnit = switchedCapacitanceIntAluUnit
    def get_switchedCapacitanceIntMulValue(self): return self.switchedCapacitanceIntMulValue
    def set_switchedCapacitanceIntMulValue(self, switchedCapacitanceIntMulValue): self.switchedCapacitanceIntMulValue = switchedCapacitanceIntMulValue
    def get_switchedCapacitanceIntMulUnit(self): return self.switchedCapacitanceIntMulUnit
    def set_switchedCapacitanceIntMulUnit(self, switchedCapacitanceIntMulUnit): self.switchedCapacitanceIntMulUnit = switchedCapacitanceIntMulUnit
    def get_switchedCapacitanceIntDivValue(self): return self.switchedCapacitanceIntDivValue
    def set_switchedCapacitanceIntDivValue(self, switchedCapacitanceIntDivValue): self.switchedCapacitanceIntDivValue = switchedCapacitanceIntDivValue
    def get_switchedCapacitanceIntDivUnit(self): return self.switchedCapacitanceIntDivUnit
    def set_switchedCapacitanceIntDivUnit(self, switchedCapacitanceIntDivUnit): self.switchedCapacitanceIntDivUnit = switchedCapacitanceIntDivUnit
    def get_switchedCapacitanceFloatArithValue(self): return self.switchedCapacitanceFloatArithValue
    def set_switchedCapacitanceFloatArithValue(self, switchedCapacitanceFloatArithValue): self.switchedCapacitanceFloatArithValue = switchedCapacitanceFloatArithValue
    def get_switchedCapacitanceFloatArithUnit(self): return self.switchedCapacitanceFloatArithUnit
    def set_switchedCapacitanceFloatArithUnit(self, switchedCapacitanceFloatArithUnit): self.switchedCapacitanceFloatArithUnit = switchedCapacitanceFloatArithUnit
    def get_switchedCapacitanceFloatCompValue(self): return self.switchedCapacitanceFloatCompValue
    def set_switchedCapacitanceFloatCompValue(self, switchedCapacitanceFloatCompValue): self.switchedCapacitanceFloatCompValue = switchedCapacitanceFloatCompValue
    def get_switchedCapacitanceFloatCompUnit(self): return self.switchedCapacitanceFloatCompUnit
    def set_switchedCapacitanceFloatCompUnit(self, switchedCapacitanceFloatCompUnit): self.switchedCapacitanceFloatCompUnit = switchedCapacitanceFloatCompUnit
    def get_switchedCapacitanceFloatMulValue(self): return self.switchedCapacitanceFloatMulValue
    def set_switchedCapacitanceFloatMulValue(self, switchedCapacitanceFloatMulValue): self.switchedCapacitanceFloatMulValue = switchedCapacitanceFloatMulValue
    def get_switchedCapacitanceFloatMulUnit(self): return self.switchedCapacitanceFloatMulUnit
    def set_switchedCapacitanceFloatMulUnit(self, switchedCapacitanceFloatMulUnit): self.switchedCapacitanceFloatMulUnit = switchedCapacitanceFloatMulUnit
    def get_switchedCapacitanceFloatDivValue(self): return self.switchedCapacitanceFloatDivValue
    def set_switchedCapacitanceFloatDivValue(self, switchedCapacitanceFloatDivValue): self.switchedCapacitanceFloatDivValue = switchedCapacitanceFloatDivValue
    def get_switchedCapacitanceFloatDivUnit(self): return self.switchedCapacitanceFloatDivUnit
    def set_switchedCapacitanceFloatDivUnit(self, switchedCapacitanceFloatDivUnit): self.switchedCapacitanceFloatDivUnit = switchedCapacitanceFloatDivUnit
    def get_switchedCapacitanceLoadValue(self): return self.switchedCapacitanceLoadValue
    def set_switchedCapacitanceLoadValue(self, switchedCapacitanceLoadValue): self.switchedCapacitanceLoadValue = switchedCapacitanceLoadValue
    def get_switchedCapacitanceLoadUnit(self): return self.switchedCapacitanceLoadUnit
    def set_switchedCapacitanceLoadUnit(self, switchedCapacitanceLoadUnit): self.switchedCapacitanceLoadUnit = switchedCapacitanceLoadUnit
    def get_switchedCapacitanceStoreValue(self): return self.switchedCapacitanceStoreValue
    def set_switchedCapacitanceStoreValue(self, switchedCapacitanceStoreValue): self.switchedCapacitanceStoreValue = switchedCapacitanceStoreValue
    def get_switchedCapacitanceStoreUnit(self): return self.switchedCapacitanceStoreUnit
    def set_switchedCapacitanceStoreUnit(self, switchedCapacitanceStoreUnit): self.switchedCapacitanceStoreUnit = switchedCapacitanceStoreUnit
    def get_switchedCapacitanceControlValue(self): return self.switchedCapacitanceControlValue
    def set_switchedCapacitanceControlValue(self, switchedCapacitanceControlValue): self.switchedCapacitanceControlValue = switchedCapacitanceControlValue
    def get_switchedCapacitanceControlUnit(self): return self.switchedCapacitanceControlUnit
    def set_switchedCapacitanceControlUnit(self, switchedCapacitanceControlUnit): self.switchedCapacitanceControlUnit = switchedCapacitanceControlUnit
    def get_switchedCapacitanceOtherValue(self): return self.switchedCapacitanceOtherValue
    def set_switchedCapacitanceOtherValue(self, switchedCapacitanceOtherValue): self.switchedCapacitanceOtherValue = switchedCapacitanceOtherValue
    def get_switchedCapacitanceOtherUnit(self): return self.switchedCapacitanceOtherUnit
    def set_switchedCapacitanceOtherUnit(self, switchedCapacitanceOtherUnit): self.switchedCapacitanceOtherUnit = switchedCapacitanceOtherUnit
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_CurrentValueType(self, value):
        # Validate type CurrentValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CurrentValueType' % {"value" : value} )
    def validate_CurrentUnitType(self, value):
        # Validate type CurrentUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pA', 'nA', 'uA', 'mA', 'A']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CurrentUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CapacitanceValueType(self, value):
        # Validate type CapacitanceValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CapacitanceValueType' % {"value" : value} )
    def validate_CapacitanceUnitType(self, value):
        # Validate type CapacitanceUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fF', 'pF', 'nF', 'uF', 'mF', 'F']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CapacitanceUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ProcessorPowerState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='ProcessorPowerModelType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessorPowerModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='ProcessorPowerModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='ProcessorPowerModelType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.leakageCurrentValue != "0" and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            outfile.write(' leakageCurrentValue=%s' % (quote_attrib(self.leakageCurrentValue), ))
        if self.leakageCurrentUnit != "pA" and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            outfile.write(' leakageCurrentUnit=%s' % (quote_attrib(self.leakageCurrentUnit), ))
        if self.switchedCapacitanceValue != "0" and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            outfile.write(' switchedCapacitanceValue=%s' % (quote_attrib(self.switchedCapacitanceValue), ))
        if self.switchedCapacitanceUnit != "pF" and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            outfile.write(' switchedCapacitanceUnit=%s' % (quote_attrib(self.switchedCapacitanceUnit), ))
        if self.switchedCapacitanceIntAluValue != "0" and 'switchedCapacitanceIntAluValue' not in already_processed:
            already_processed.add('switchedCapacitanceIntAluValue')
            outfile.write(' switchedCapacitanceIntAluValue=%s' % (quote_attrib(self.switchedCapacitanceIntAluValue), ))
        if self.switchedCapacitanceIntAluUnit != "pF" and 'switchedCapacitanceIntAluUnit' not in already_processed:
            already_processed.add('switchedCapacitanceIntAluUnit')
            outfile.write(' switchedCapacitanceIntAluUnit=%s' % (quote_attrib(self.switchedCapacitanceIntAluUnit), ))
        if self.switchedCapacitanceIntMulValue != "0" and 'switchedCapacitanceIntMulValue' not in already_processed:
            already_processed.add('switchedCapacitanceIntMulValue')
            outfile.write(' switchedCapacitanceIntMulValue=%s' % (quote_attrib(self.switchedCapacitanceIntMulValue), ))
        if self.switchedCapacitanceIntMulUnit != "pF" and 'switchedCapacitanceIntMulUnit' not in already_processed:
            already_processed.add('switchedCapacitanceIntMulUnit')
            outfile.write(' switchedCapacitanceIntMulUnit=%s' % (quote_attrib(self.switchedCapacitanceIntMulUnit), ))
        if self.switchedCapacitanceIntDivValue != "0" and 'switchedCapacitanceIntDivValue' not in already_processed:
            already_processed.add('switchedCapacitanceIntDivValue')
            outfile.write(' switchedCapacitanceIntDivValue=%s' % (quote_attrib(self.switchedCapacitanceIntDivValue), ))
        if self.switchedCapacitanceIntDivUnit != "pF" and 'switchedCapacitanceIntDivUnit' not in already_processed:
            already_processed.add('switchedCapacitanceIntDivUnit')
            outfile.write(' switchedCapacitanceIntDivUnit=%s' % (quote_attrib(self.switchedCapacitanceIntDivUnit), ))
        if self.switchedCapacitanceFloatArithValue != "0" and 'switchedCapacitanceFloatArithValue' not in already_processed:
            already_processed.add('switchedCapacitanceFloatArithValue')
            outfile.write(' switchedCapacitanceFloatArithValue=%s' % (quote_attrib(self.switchedCapacitanceFloatArithValue), ))
        if self.switchedCapacitanceFloatArithUnit != "pF" and 'switchedCapacitanceFloatArithUnit' not in already_processed:
            already_processed.add('switchedCapacitanceFloatArithUnit')
            outfile.write(' switchedCapacitanceFloatArithUnit=%s' % (quote_attrib(self.switchedCapacitanceFloatArithUnit), ))
        if self.switchedCapacitanceFloatCompValue != "0" and 'switchedCapacitanceFloatCompValue' not in already_processed:
            already_processed.add('switchedCapacitanceFloatCompValue')
            outfile.write(' switchedCapacitanceFloatCompValue=%s' % (quote_attrib(self.switchedCapacitanceFloatCompValue), ))
        if self.switchedCapacitanceFloatCompUnit != "pF" and 'switchedCapacitanceFloatCompUnit' not in already_processed:
            already_processed.add('switchedCapacitanceFloatCompUnit')
            outfile.write(' switchedCapacitanceFloatCompUnit=%s' % (quote_attrib(self.switchedCapacitanceFloatCompUnit), ))
        if self.switchedCapacitanceFloatMulValue != "0" and 'switchedCapacitanceFloatMulValue' not in already_processed:
            already_processed.add('switchedCapacitanceFloatMulValue')
            outfile.write(' switchedCapacitanceFloatMulValue=%s' % (quote_attrib(self.switchedCapacitanceFloatMulValue), ))
        if self.switchedCapacitanceFloatMulUnit != "pF" and 'switchedCapacitanceFloatMulUnit' not in already_processed:
            already_processed.add('switchedCapacitanceFloatMulUnit')
            outfile.write(' switchedCapacitanceFloatMulUnit=%s' % (quote_attrib(self.switchedCapacitanceFloatMulUnit), ))
        if self.switchedCapacitanceFloatDivValue != "0" and 'switchedCapacitanceFloatDivValue' not in already_processed:
            already_processed.add('switchedCapacitanceFloatDivValue')
            outfile.write(' switchedCapacitanceFloatDivValue=%s' % (quote_attrib(self.switchedCapacitanceFloatDivValue), ))
        if self.switchedCapacitanceFloatDivUnit != "pF" and 'switchedCapacitanceFloatDivUnit' not in already_processed:
            already_processed.add('switchedCapacitanceFloatDivUnit')
            outfile.write(' switchedCapacitanceFloatDivUnit=%s' % (quote_attrib(self.switchedCapacitanceFloatDivUnit), ))
        if self.switchedCapacitanceLoadValue != "0" and 'switchedCapacitanceLoadValue' not in already_processed:
            already_processed.add('switchedCapacitanceLoadValue')
            outfile.write(' switchedCapacitanceLoadValue=%s' % (quote_attrib(self.switchedCapacitanceLoadValue), ))
        if self.switchedCapacitanceLoadUnit != "pF" and 'switchedCapacitanceLoadUnit' not in already_processed:
            already_processed.add('switchedCapacitanceLoadUnit')
            outfile.write(' switchedCapacitanceLoadUnit=%s' % (quote_attrib(self.switchedCapacitanceLoadUnit), ))
        if self.switchedCapacitanceStoreValue != "0" and 'switchedCapacitanceStoreValue' not in already_processed:
            already_processed.add('switchedCapacitanceStoreValue')
            outfile.write(' switchedCapacitanceStoreValue=%s' % (quote_attrib(self.switchedCapacitanceStoreValue), ))
        if self.switchedCapacitanceStoreUnit != "pF" and 'switchedCapacitanceStoreUnit' not in already_processed:
            already_processed.add('switchedCapacitanceStoreUnit')
            outfile.write(' switchedCapacitanceStoreUnit=%s' % (quote_attrib(self.switchedCapacitanceStoreUnit), ))
        if self.switchedCapacitanceControlValue != "0" and 'switchedCapacitanceControlValue' not in already_processed:
            already_processed.add('switchedCapacitanceControlValue')
            outfile.write(' switchedCapacitanceControlValue=%s' % (quote_attrib(self.switchedCapacitanceControlValue), ))
        if self.switchedCapacitanceControlUnit != "pF" and 'switchedCapacitanceControlUnit' not in already_processed:
            already_processed.add('switchedCapacitanceControlUnit')
            outfile.write(' switchedCapacitanceControlUnit=%s' % (quote_attrib(self.switchedCapacitanceControlUnit), ))
        if self.switchedCapacitanceOtherValue != "0" and 'switchedCapacitanceOtherValue' not in already_processed:
            already_processed.add('switchedCapacitanceOtherValue')
            outfile.write(' switchedCapacitanceOtherValue=%s' % (quote_attrib(self.switchedCapacitanceOtherValue), ))
        if self.switchedCapacitanceOtherUnit != "pF" and 'switchedCapacitanceOtherUnit' not in already_processed:
            already_processed.add('switchedCapacitanceOtherUnit')
            outfile.write(' switchedCapacitanceOtherUnit=%s' % (quote_attrib(self.switchedCapacitanceOtherUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='ProcessorPowerModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProcessorPowerState_ in self.ProcessorPowerState:
            ProcessorPowerState_.export(outfile, level, namespace_, name_='ProcessorPowerState', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('leakageCurrentValue', node)
        if value is not None and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            self.leakageCurrentValue = value
            self.validate_CurrentValueType(self.leakageCurrentValue)    # validate type CurrentValueType
        value = find_attr_value_('leakageCurrentUnit', node)
        if value is not None and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            self.leakageCurrentUnit = value
            self.validate_CurrentUnitType(self.leakageCurrentUnit)    # validate type CurrentUnitType
        value = find_attr_value_('switchedCapacitanceValue', node)
        if value is not None and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            self.switchedCapacitanceValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceUnit', node)
        if value is not None and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            self.switchedCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceIntAluValue', node)
        if value is not None and 'switchedCapacitanceIntAluValue' not in already_processed:
            already_processed.add('switchedCapacitanceIntAluValue')
            self.switchedCapacitanceIntAluValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceIntAluValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceIntAluUnit', node)
        if value is not None and 'switchedCapacitanceIntAluUnit' not in already_processed:
            already_processed.add('switchedCapacitanceIntAluUnit')
            self.switchedCapacitanceIntAluUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceIntAluUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceIntMulValue', node)
        if value is not None and 'switchedCapacitanceIntMulValue' not in already_processed:
            already_processed.add('switchedCapacitanceIntMulValue')
            self.switchedCapacitanceIntMulValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceIntMulValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceIntMulUnit', node)
        if value is not None and 'switchedCapacitanceIntMulUnit' not in already_processed:
            already_processed.add('switchedCapacitanceIntMulUnit')
            self.switchedCapacitanceIntMulUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceIntMulUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceIntDivValue', node)
        if value is not None and 'switchedCapacitanceIntDivValue' not in already_processed:
            already_processed.add('switchedCapacitanceIntDivValue')
            self.switchedCapacitanceIntDivValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceIntDivValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceIntDivUnit', node)
        if value is not None and 'switchedCapacitanceIntDivUnit' not in already_processed:
            already_processed.add('switchedCapacitanceIntDivUnit')
            self.switchedCapacitanceIntDivUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceIntDivUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceFloatArithValue', node)
        if value is not None and 'switchedCapacitanceFloatArithValue' not in already_processed:
            already_processed.add('switchedCapacitanceFloatArithValue')
            self.switchedCapacitanceFloatArithValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceFloatArithValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceFloatArithUnit', node)
        if value is not None and 'switchedCapacitanceFloatArithUnit' not in already_processed:
            already_processed.add('switchedCapacitanceFloatArithUnit')
            self.switchedCapacitanceFloatArithUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceFloatArithUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceFloatCompValue', node)
        if value is not None and 'switchedCapacitanceFloatCompValue' not in already_processed:
            already_processed.add('switchedCapacitanceFloatCompValue')
            self.switchedCapacitanceFloatCompValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceFloatCompValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceFloatCompUnit', node)
        if value is not None and 'switchedCapacitanceFloatCompUnit' not in already_processed:
            already_processed.add('switchedCapacitanceFloatCompUnit')
            self.switchedCapacitanceFloatCompUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceFloatCompUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceFloatMulValue', node)
        if value is not None and 'switchedCapacitanceFloatMulValue' not in already_processed:
            already_processed.add('switchedCapacitanceFloatMulValue')
            self.switchedCapacitanceFloatMulValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceFloatMulValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceFloatMulUnit', node)
        if value is not None and 'switchedCapacitanceFloatMulUnit' not in already_processed:
            already_processed.add('switchedCapacitanceFloatMulUnit')
            self.switchedCapacitanceFloatMulUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceFloatMulUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceFloatDivValue', node)
        if value is not None and 'switchedCapacitanceFloatDivValue' not in already_processed:
            already_processed.add('switchedCapacitanceFloatDivValue')
            self.switchedCapacitanceFloatDivValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceFloatDivValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceFloatDivUnit', node)
        if value is not None and 'switchedCapacitanceFloatDivUnit' not in already_processed:
            already_processed.add('switchedCapacitanceFloatDivUnit')
            self.switchedCapacitanceFloatDivUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceFloatDivUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceLoadValue', node)
        if value is not None and 'switchedCapacitanceLoadValue' not in already_processed:
            already_processed.add('switchedCapacitanceLoadValue')
            self.switchedCapacitanceLoadValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceLoadValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceLoadUnit', node)
        if value is not None and 'switchedCapacitanceLoadUnit' not in already_processed:
            already_processed.add('switchedCapacitanceLoadUnit')
            self.switchedCapacitanceLoadUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceLoadUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceStoreValue', node)
        if value is not None and 'switchedCapacitanceStoreValue' not in already_processed:
            already_processed.add('switchedCapacitanceStoreValue')
            self.switchedCapacitanceStoreValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceStoreValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceStoreUnit', node)
        if value is not None and 'switchedCapacitanceStoreUnit' not in already_processed:
            already_processed.add('switchedCapacitanceStoreUnit')
            self.switchedCapacitanceStoreUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceStoreUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceControlValue', node)
        if value is not None and 'switchedCapacitanceControlValue' not in already_processed:
            already_processed.add('switchedCapacitanceControlValue')
            self.switchedCapacitanceControlValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceControlValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceControlUnit', node)
        if value is not None and 'switchedCapacitanceControlUnit' not in already_processed:
            already_processed.add('switchedCapacitanceControlUnit')
            self.switchedCapacitanceControlUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceControlUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('switchedCapacitanceOtherValue', node)
        if value is not None and 'switchedCapacitanceOtherValue' not in already_processed:
            already_processed.add('switchedCapacitanceOtherValue')
            self.switchedCapacitanceOtherValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceOtherValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceOtherUnit', node)
        if value is not None and 'switchedCapacitanceOtherUnit' not in already_processed:
            already_processed.add('switchedCapacitanceOtherUnit')
            self.switchedCapacitanceOtherUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceOtherUnit)    # validate type CapacitanceUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProcessorPowerState':
            obj_ = ProcessorPowerStateType.factory()
            obj_.build(child_)
            self.ProcessorPowerState.append(obj_)
            obj_.original_tagname_ = 'ProcessorPowerState'
# end class ProcessorPowerModelType


class ProcessorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, core=None, isHardware='false', isAccelerator='false', frequencyDomain=None, clockGating=None, voltageDomain=None, processorPowerModel=None, scheduler=None, contextLoadValue='0', contextLoadUnit='cycles', contextStoreValue='0', contextStoreUnit='cycles', DataCacheRef=None, InstructionCacheRef=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.core = _cast(None, core)
        self.isHardware = _cast(None, isHardware)
        self.isAccelerator = _cast(None, isAccelerator)
        self.frequencyDomain = _cast(None, frequencyDomain)
        self.clockGating = _cast(None, clockGating)
        self.voltageDomain = _cast(None, voltageDomain)
        self.processorPowerModel = _cast(None, processorPowerModel)
        self.scheduler = _cast(None, scheduler)
        self.contextLoadValue = _cast(None, contextLoadValue)
        self.contextLoadUnit = _cast(None, contextLoadUnit)
        self.contextStoreValue = _cast(None, contextStoreValue)
        self.contextStoreUnit = _cast(None, contextStoreUnit)
        self.DataCacheRef = DataCacheRef
        self.InstructionCacheRef = InstructionCacheRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessorType.subclass:
            return ProcessorType.subclass(*args_, **kwargs_)
        else:
            return ProcessorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataCacheRef(self): return self.DataCacheRef
    def set_DataCacheRef(self, DataCacheRef): self.DataCacheRef = DataCacheRef
    def get_InstructionCacheRef(self): return self.InstructionCacheRef
    def set_InstructionCacheRef(self, InstructionCacheRef): self.InstructionCacheRef = InstructionCacheRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_core(self): return self.core
    def set_core(self, core): self.core = core
    def get_isHardware(self): return self.isHardware
    def set_isHardware(self, isHardware): self.isHardware = isHardware
    def get_isAccelerator(self): return self.isAccelerator
    def set_isAccelerator(self, isAccelerator): self.isAccelerator = isAccelerator
    def get_frequencyDomain(self): return self.frequencyDomain
    def set_frequencyDomain(self, frequencyDomain): self.frequencyDomain = frequencyDomain
    def get_clockGating(self): return self.clockGating
    def set_clockGating(self, clockGating): self.clockGating = clockGating
    def get_voltageDomain(self): return self.voltageDomain
    def set_voltageDomain(self, voltageDomain): self.voltageDomain = voltageDomain
    def get_processorPowerModel(self): return self.processorPowerModel
    def set_processorPowerModel(self, processorPowerModel): self.processorPowerModel = processorPowerModel
    def get_scheduler(self): return self.scheduler
    def set_scheduler(self, scheduler): self.scheduler = scheduler
    def get_contextLoadValue(self): return self.contextLoadValue
    def set_contextLoadValue(self, contextLoadValue): self.contextLoadValue = contextLoadValue
    def get_contextLoadUnit(self): return self.contextLoadUnit
    def set_contextLoadUnit(self, contextLoadUnit): self.contextLoadUnit = contextLoadUnit
    def get_contextStoreValue(self): return self.contextStoreValue
    def set_contextStoreValue(self, contextStoreValue): self.contextStoreValue = contextStoreValue
    def get_contextStoreUnit(self): return self.contextStoreUnit
    def set_contextStoreUnit(self, contextStoreUnit): self.contextStoreUnit = contextStoreUnit
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_NameType(self, value):
        # Validate type NameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NameType_patterns_, ))
    validate_NameType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_BooleanType(self, value):
        # Validate type BooleanType, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_CyclesValueType(self, value):
        # Validate type CyclesValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CyclesValueType' % {"value" : value} )
    def validate_CyclesUnitType(self, value):
        # Validate type CyclesUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cycles', 'kcycles', 'Mcycles']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CyclesUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DataCacheRef is not None or
            self.InstructionCacheRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='ProcessorType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='ProcessorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='ProcessorType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.core is not None and 'core' not in already_processed:
            already_processed.add('core')
            outfile.write(' core=%s' % (quote_attrib(self.core), ))
        if self.isHardware and 'isHardware' not in already_processed:
            already_processed.add('isHardware')
            outfile.write(' isHardware=%s' % (quote_attrib(self.isHardware), ))
        if self.isAccelerator and 'isAccelerator' not in already_processed:
            already_processed.add('isAccelerator')
            outfile.write(' isAccelerator=%s' % (quote_attrib(self.isAccelerator), ))
        if self.frequencyDomain is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            outfile.write(' frequencyDomain=%s' % (quote_attrib(self.frequencyDomain), ))
        if self.clockGating is not None and 'clockGating' not in already_processed:
            already_processed.add('clockGating')
            outfile.write(' clockGating=%s' % (quote_attrib(self.clockGating), ))
        if self.voltageDomain is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            outfile.write(' voltageDomain=%s' % (quote_attrib(self.voltageDomain), ))
        if self.processorPowerModel is not None and 'processorPowerModel' not in already_processed:
            already_processed.add('processorPowerModel')
            outfile.write(' processorPowerModel=%s' % (quote_attrib(self.processorPowerModel), ))
        if self.scheduler is not None and 'scheduler' not in already_processed:
            already_processed.add('scheduler')
            outfile.write(' scheduler=%s' % (quote_attrib(self.scheduler), ))
        if self.contextLoadValue != "0" and 'contextLoadValue' not in already_processed:
            already_processed.add('contextLoadValue')
            outfile.write(' contextLoadValue=%s' % (quote_attrib(self.contextLoadValue), ))
        if self.contextLoadUnit != "cycles" and 'contextLoadUnit' not in already_processed:
            already_processed.add('contextLoadUnit')
            outfile.write(' contextLoadUnit=%s' % (quote_attrib(self.contextLoadUnit), ))
        if self.contextStoreValue != "0" and 'contextStoreValue' not in already_processed:
            already_processed.add('contextStoreValue')
            outfile.write(' contextStoreValue=%s' % (quote_attrib(self.contextStoreValue), ))
        if self.contextStoreUnit != "cycles" and 'contextStoreUnit' not in already_processed:
            already_processed.add('contextStoreUnit')
            outfile.write(' contextStoreUnit=%s' % (quote_attrib(self.contextStoreUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='ProcessorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataCacheRef is not None:
            self.DataCacheRef.export(outfile, level, namespace_, name_='DataCacheRef', pretty_print=pretty_print)
        if self.InstructionCacheRef is not None:
            self.InstructionCacheRef.export(outfile, level, namespace_, name_='InstructionCacheRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('core', node)
        if value is not None and 'core' not in already_processed:
            already_processed.add('core')
            self.core = value
            self.validate_NameType(self.core)    # validate type NameType
        value = find_attr_value_('isHardware', node)
        if value is not None and 'isHardware' not in already_processed:
            already_processed.add('isHardware')
            if value in ('true', '1'):
                self.isHardware = True
            elif value in ('false', '0'):
                self.isHardware = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_BooleanType(self.isHardware)    # validate type BooleanType
        value = find_attr_value_('isAccelerator', node)
        if value is not None and 'isAccelerator' not in already_processed:
            already_processed.add('isAccelerator')
            if value in ('true', '1'):
                self.isAccelerator = True
            elif value in ('false', '0'):
                self.isAccelerator = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_BooleanType(self.isAccelerator)    # validate type BooleanType
        value = find_attr_value_('frequencyDomain', node)
        if value is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            self.frequencyDomain = value
            self.validate_RefType(self.frequencyDomain)    # validate type RefType
        value = find_attr_value_('clockGating', node)
        if value is not None and 'clockGating' not in already_processed:
            already_processed.add('clockGating')
            if value in ('true', '1'):
                self.clockGating = True
            elif value in ('false', '0'):
                self.clockGating = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_BooleanType(self.clockGating)    # validate type BooleanType
        value = find_attr_value_('voltageDomain', node)
        if value is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            self.voltageDomain = value
            self.validate_RefType(self.voltageDomain)    # validate type RefType
        value = find_attr_value_('processorPowerModel', node)
        if value is not None and 'processorPowerModel' not in already_processed:
            already_processed.add('processorPowerModel')
            self.processorPowerModel = value
            self.validate_RefType(self.processorPowerModel)    # validate type RefType
        value = find_attr_value_('scheduler', node)
        if value is not None and 'scheduler' not in already_processed:
            already_processed.add('scheduler')
            self.scheduler = value
            self.validate_RefType(self.scheduler)    # validate type RefType
        value = find_attr_value_('contextLoadValue', node)
        if value is not None and 'contextLoadValue' not in already_processed:
            already_processed.add('contextLoadValue')
            self.contextLoadValue = value
            self.validate_CyclesValueType(self.contextLoadValue)    # validate type CyclesValueType
        value = find_attr_value_('contextLoadUnit', node)
        if value is not None and 'contextLoadUnit' not in already_processed:
            already_processed.add('contextLoadUnit')
            self.contextLoadUnit = value
            self.validate_CyclesUnitType(self.contextLoadUnit)    # validate type CyclesUnitType
        value = find_attr_value_('contextStoreValue', node)
        if value is not None and 'contextStoreValue' not in already_processed:
            already_processed.add('contextStoreValue')
            self.contextStoreValue = value
            self.validate_CyclesValueType(self.contextStoreValue)    # validate type CyclesValueType
        value = find_attr_value_('contextStoreUnit', node)
        if value is not None and 'contextStoreUnit' not in already_processed:
            already_processed.add('contextStoreUnit')
            self.contextStoreUnit = value
            self.validate_CyclesUnitType(self.contextStoreUnit)    # validate type CyclesUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataCacheRef':
            class_obj_ = self.get_class_obj_(child_, CacheRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.DataCacheRef = obj_
            obj_.original_tagname_ = 'DataCacheRef'
        elif nodeName_ == 'InstructionCacheRef':
            class_obj_ = self.get_class_obj_(child_, CacheRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.InstructionCacheRef = obj_
            obj_.original_tagname_ = 'InstructionCacheRef'
# end class ProcessorType


class ProcessorRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, processor=None):
        self.original_tagname_ = None
        self.processor = _cast(None, processor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessorRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessorRefType.subclass:
            return ProcessorRefType.subclass(*args_, **kwargs_)
        else:
            return ProcessorRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processor(self): return self.processor
    def set_processor(self, processor): self.processor = processor
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='ProcessorRefType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessorRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='ProcessorRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='ProcessorRefType'):
        if self.processor is not None and 'processor' not in already_processed:
            already_processed.add('processor')
            outfile.write(' processor=%s' % (quote_attrib(self.processor), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='ProcessorRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('processor', node)
        if value is not None and 'processor' not in already_processed:
            already_processed.add('processor')
            self.processor = value
            self.validate_RefType(self.processor)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProcessorRefType


class MemoryPowerStateType(VoltageFrequencyConditionListType):
    subclass = None
    superclass = VoltageFrequencyConditionListType
    def __init__(self, VoltageCondition=None, FrequencyCondition=None, FrequencyVoltageCondition=None, name=None, powerValue=None, powerUnit='pW'):
        self.original_tagname_ = None
        super(MemoryPowerStateType, self).__init__(VoltageCondition, FrequencyCondition, FrequencyVoltageCondition, )
        self.name = _cast(None, name)
        self.powerValue = _cast(None, powerValue)
        self.powerUnit = _cast(None, powerUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemoryPowerStateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemoryPowerStateType.subclass:
            return MemoryPowerStateType.subclass(*args_, **kwargs_)
        else:
            return MemoryPowerStateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_powerValue(self): return self.powerValue
    def set_powerValue(self, powerValue): self.powerValue = powerValue
    def get_powerUnit(self): return self.powerUnit
    def set_powerUnit(self, powerUnit): self.powerUnit = powerUnit
    def validate_NameType(self, value):
        # Validate type NameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NameType_patterns_, ))
    validate_NameType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_PowerValueType(self, value):
        # Validate type PowerValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PowerValueType' % {"value" : value} )
    def validate_PowerUnitType(self, value):
        # Validate type PowerUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pW', 'nW', 'uW', 'mW', 'W']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PowerUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(MemoryPowerStateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='MemoryPowerStateType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemoryPowerStateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='MemoryPowerStateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='MemoryPowerStateType'):
        super(MemoryPowerStateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MemoryPowerStateType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.powerValue is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            outfile.write(' powerValue=%s' % (quote_attrib(self.powerValue), ))
        if self.powerUnit != "pW" and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            outfile.write(' powerUnit=%s' % (quote_attrib(self.powerUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='MemoryPowerStateType', fromsubclass_=False, pretty_print=True):
        super(MemoryPowerStateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NameType(self.name)    # validate type NameType
        value = find_attr_value_('powerValue', node)
        if value is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            self.powerValue = value
            self.validate_PowerValueType(self.powerValue)    # validate type PowerValueType
        value = find_attr_value_('powerUnit', node)
        if value is not None and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            self.powerUnit = value
            self.validate_PowerUnitType(self.powerUnit)    # validate type PowerUnitType
        super(MemoryPowerStateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MemoryPowerStateType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MemoryPowerStateType


class MemoryPowerModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, leakageCurrentValue='0', leakageCurrentUnit='pA', cellLeakageCurrentValue='0', cellLeakageCurrentUnit='pA', switchedCapacitanceValue='0', switchedCapacitanceUnit='pF', cellSwitchedCapacitanceValue='0', cellSwitchedCapacitanceUnit='pF', readCapacitanceValue='0', readCapacitanceUnit='pF', writeCapacitanceValue='0', writeCapacitanceUnit='pF', MemoryPowerState=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.leakageCurrentValue = _cast(None, leakageCurrentValue)
        self.leakageCurrentUnit = _cast(None, leakageCurrentUnit)
        self.cellLeakageCurrentValue = _cast(None, cellLeakageCurrentValue)
        self.cellLeakageCurrentUnit = _cast(None, cellLeakageCurrentUnit)
        self.switchedCapacitanceValue = _cast(None, switchedCapacitanceValue)
        self.switchedCapacitanceUnit = _cast(None, switchedCapacitanceUnit)
        self.cellSwitchedCapacitanceValue = _cast(None, cellSwitchedCapacitanceValue)
        self.cellSwitchedCapacitanceUnit = _cast(None, cellSwitchedCapacitanceUnit)
        self.readCapacitanceValue = _cast(None, readCapacitanceValue)
        self.readCapacitanceUnit = _cast(None, readCapacitanceUnit)
        self.writeCapacitanceValue = _cast(None, writeCapacitanceValue)
        self.writeCapacitanceUnit = _cast(None, writeCapacitanceUnit)
        if MemoryPowerState is None:
            self.MemoryPowerState = []
        else:
            self.MemoryPowerState = MemoryPowerState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemoryPowerModelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemoryPowerModelType.subclass:
            return MemoryPowerModelType.subclass(*args_, **kwargs_)
        else:
            return MemoryPowerModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MemoryPowerState(self): return self.MemoryPowerState
    def set_MemoryPowerState(self, MemoryPowerState): self.MemoryPowerState = MemoryPowerState
    def add_MemoryPowerState(self, value): self.MemoryPowerState.append(value)
    def insert_MemoryPowerState_at(self, index, value): self.MemoryPowerState.insert(index, value)
    def replace_MemoryPowerState_at(self, index, value): self.MemoryPowerState[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_leakageCurrentValue(self): return self.leakageCurrentValue
    def set_leakageCurrentValue(self, leakageCurrentValue): self.leakageCurrentValue = leakageCurrentValue
    def get_leakageCurrentUnit(self): return self.leakageCurrentUnit
    def set_leakageCurrentUnit(self, leakageCurrentUnit): self.leakageCurrentUnit = leakageCurrentUnit
    def get_cellLeakageCurrentValue(self): return self.cellLeakageCurrentValue
    def set_cellLeakageCurrentValue(self, cellLeakageCurrentValue): self.cellLeakageCurrentValue = cellLeakageCurrentValue
    def get_cellLeakageCurrentUnit(self): return self.cellLeakageCurrentUnit
    def set_cellLeakageCurrentUnit(self, cellLeakageCurrentUnit): self.cellLeakageCurrentUnit = cellLeakageCurrentUnit
    def get_switchedCapacitanceValue(self): return self.switchedCapacitanceValue
    def set_switchedCapacitanceValue(self, switchedCapacitanceValue): self.switchedCapacitanceValue = switchedCapacitanceValue
    def get_switchedCapacitanceUnit(self): return self.switchedCapacitanceUnit
    def set_switchedCapacitanceUnit(self, switchedCapacitanceUnit): self.switchedCapacitanceUnit = switchedCapacitanceUnit
    def get_cellSwitchedCapacitanceValue(self): return self.cellSwitchedCapacitanceValue
    def set_cellSwitchedCapacitanceValue(self, cellSwitchedCapacitanceValue): self.cellSwitchedCapacitanceValue = cellSwitchedCapacitanceValue
    def get_cellSwitchedCapacitanceUnit(self): return self.cellSwitchedCapacitanceUnit
    def set_cellSwitchedCapacitanceUnit(self, cellSwitchedCapacitanceUnit): self.cellSwitchedCapacitanceUnit = cellSwitchedCapacitanceUnit
    def get_readCapacitanceValue(self): return self.readCapacitanceValue
    def set_readCapacitanceValue(self, readCapacitanceValue): self.readCapacitanceValue = readCapacitanceValue
    def get_readCapacitanceUnit(self): return self.readCapacitanceUnit
    def set_readCapacitanceUnit(self, readCapacitanceUnit): self.readCapacitanceUnit = readCapacitanceUnit
    def get_writeCapacitanceValue(self): return self.writeCapacitanceValue
    def set_writeCapacitanceValue(self, writeCapacitanceValue): self.writeCapacitanceValue = writeCapacitanceValue
    def get_writeCapacitanceUnit(self): return self.writeCapacitanceUnit
    def set_writeCapacitanceUnit(self, writeCapacitanceUnit): self.writeCapacitanceUnit = writeCapacitanceUnit
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_CurrentValueType(self, value):
        # Validate type CurrentValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CurrentValueType' % {"value" : value} )
    def validate_CurrentUnitType(self, value):
        # Validate type CurrentUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pA', 'nA', 'uA', 'mA', 'A']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CurrentUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CapacitanceValueType(self, value):
        # Validate type CapacitanceValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CapacitanceValueType' % {"value" : value} )
    def validate_CapacitanceUnitType(self, value):
        # Validate type CapacitanceUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fF', 'pF', 'nF', 'uF', 'mF', 'F']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CapacitanceUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MemoryPowerState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='MemoryPowerModelType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemoryPowerModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='MemoryPowerModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='MemoryPowerModelType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.leakageCurrentValue != "0" and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            outfile.write(' leakageCurrentValue=%s' % (quote_attrib(self.leakageCurrentValue), ))
        if self.leakageCurrentUnit != "pA" and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            outfile.write(' leakageCurrentUnit=%s' % (quote_attrib(self.leakageCurrentUnit), ))
        if self.cellLeakageCurrentValue != "0" and 'cellLeakageCurrentValue' not in already_processed:
            already_processed.add('cellLeakageCurrentValue')
            outfile.write(' cellLeakageCurrentValue=%s' % (quote_attrib(self.cellLeakageCurrentValue), ))
        if self.cellLeakageCurrentUnit != "pA" and 'cellLeakageCurrentUnit' not in already_processed:
            already_processed.add('cellLeakageCurrentUnit')
            outfile.write(' cellLeakageCurrentUnit=%s' % (quote_attrib(self.cellLeakageCurrentUnit), ))
        if self.switchedCapacitanceValue != "0" and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            outfile.write(' switchedCapacitanceValue=%s' % (quote_attrib(self.switchedCapacitanceValue), ))
        if self.switchedCapacitanceUnit != "pF" and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            outfile.write(' switchedCapacitanceUnit=%s' % (quote_attrib(self.switchedCapacitanceUnit), ))
        if self.cellSwitchedCapacitanceValue != "0" and 'cellSwitchedCapacitanceValue' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceValue')
            outfile.write(' cellSwitchedCapacitanceValue=%s' % (quote_attrib(self.cellSwitchedCapacitanceValue), ))
        if self.cellSwitchedCapacitanceUnit != "pF" and 'cellSwitchedCapacitanceUnit' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceUnit')
            outfile.write(' cellSwitchedCapacitanceUnit=%s' % (quote_attrib(self.cellSwitchedCapacitanceUnit), ))
        if self.readCapacitanceValue != "0" and 'readCapacitanceValue' not in already_processed:
            already_processed.add('readCapacitanceValue')
            outfile.write(' readCapacitanceValue=%s' % (quote_attrib(self.readCapacitanceValue), ))
        if self.readCapacitanceUnit != "pF" and 'readCapacitanceUnit' not in already_processed:
            already_processed.add('readCapacitanceUnit')
            outfile.write(' readCapacitanceUnit=%s' % (quote_attrib(self.readCapacitanceUnit), ))
        if self.writeCapacitanceValue != "0" and 'writeCapacitanceValue' not in already_processed:
            already_processed.add('writeCapacitanceValue')
            outfile.write(' writeCapacitanceValue=%s' % (quote_attrib(self.writeCapacitanceValue), ))
        if self.writeCapacitanceUnit != "pF" and 'writeCapacitanceUnit' not in already_processed:
            already_processed.add('writeCapacitanceUnit')
            outfile.write(' writeCapacitanceUnit=%s' % (quote_attrib(self.writeCapacitanceUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='MemoryPowerModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MemoryPowerState_ in self.MemoryPowerState:
            MemoryPowerState_.export(outfile, level, namespace_, name_='MemoryPowerState', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('leakageCurrentValue', node)
        if value is not None and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            self.leakageCurrentValue = value
            self.validate_CurrentValueType(self.leakageCurrentValue)    # validate type CurrentValueType
        value = find_attr_value_('leakageCurrentUnit', node)
        if value is not None and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            self.leakageCurrentUnit = value
            self.validate_CurrentUnitType(self.leakageCurrentUnit)    # validate type CurrentUnitType
        value = find_attr_value_('cellLeakageCurrentValue', node)
        if value is not None and 'cellLeakageCurrentValue' not in already_processed:
            already_processed.add('cellLeakageCurrentValue')
            self.cellLeakageCurrentValue = value
            self.validate_CurrentValueType(self.cellLeakageCurrentValue)    # validate type CurrentValueType
        value = find_attr_value_('cellLeakageCurrentUnit', node)
        if value is not None and 'cellLeakageCurrentUnit' not in already_processed:
            already_processed.add('cellLeakageCurrentUnit')
            self.cellLeakageCurrentUnit = value
            self.validate_CurrentUnitType(self.cellLeakageCurrentUnit)    # validate type CurrentUnitType
        value = find_attr_value_('switchedCapacitanceValue', node)
        if value is not None and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            self.switchedCapacitanceValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceUnit', node)
        if value is not None and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            self.switchedCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('cellSwitchedCapacitanceValue', node)
        if value is not None and 'cellSwitchedCapacitanceValue' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceValue')
            self.cellSwitchedCapacitanceValue = value
            self.validate_CapacitanceValueType(self.cellSwitchedCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('cellSwitchedCapacitanceUnit', node)
        if value is not None and 'cellSwitchedCapacitanceUnit' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceUnit')
            self.cellSwitchedCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.cellSwitchedCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('readCapacitanceValue', node)
        if value is not None and 'readCapacitanceValue' not in already_processed:
            already_processed.add('readCapacitanceValue')
            self.readCapacitanceValue = value
            self.validate_CapacitanceValueType(self.readCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('readCapacitanceUnit', node)
        if value is not None and 'readCapacitanceUnit' not in already_processed:
            already_processed.add('readCapacitanceUnit')
            self.readCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.readCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('writeCapacitanceValue', node)
        if value is not None and 'writeCapacitanceValue' not in already_processed:
            already_processed.add('writeCapacitanceValue')
            self.writeCapacitanceValue = value
            self.validate_CapacitanceValueType(self.writeCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('writeCapacitanceUnit', node)
        if value is not None and 'writeCapacitanceUnit' not in already_processed:
            already_processed.add('writeCapacitanceUnit')
            self.writeCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.writeCapacitanceUnit)    # validate type CapacitanceUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MemoryPowerState':
            obj_ = MemoryPowerStateType.factory()
            obj_.build(child_)
            self.MemoryPowerState.append(obj_)
            obj_.original_tagname_ = 'MemoryPowerState'
# end class MemoryPowerModelType


class MemoryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, sizeValue=None, sizeUnit=None, readThroughputValue=None, readThroughputUnit='bit/cycle', readLatencyValue='0', readLatencyUnit='cycles', writeThroughputValue=None, writeThroughputUnit='bit/cycle', writeLatencyValue='0', writeLatencyUnit='cycles', frequencyDomain=None, voltageDomain=None, memoryPowerModel=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.sizeValue = _cast(None, sizeValue)
        self.sizeUnit = _cast(None, sizeUnit)
        self.readThroughputValue = _cast(None, readThroughputValue)
        self.readThroughputUnit = _cast(None, readThroughputUnit)
        self.readLatencyValue = _cast(None, readLatencyValue)
        self.readLatencyUnit = _cast(None, readLatencyUnit)
        self.writeThroughputValue = _cast(None, writeThroughputValue)
        self.writeThroughputUnit = _cast(None, writeThroughputUnit)
        self.writeLatencyValue = _cast(None, writeLatencyValue)
        self.writeLatencyUnit = _cast(None, writeLatencyUnit)
        self.frequencyDomain = _cast(None, frequencyDomain)
        self.voltageDomain = _cast(None, voltageDomain)
        self.memoryPowerModel = _cast(None, memoryPowerModel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemoryType.subclass:
            return MemoryType.subclass(*args_, **kwargs_)
        else:
            return MemoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_sizeValue(self): return self.sizeValue
    def set_sizeValue(self, sizeValue): self.sizeValue = sizeValue
    def get_sizeUnit(self): return self.sizeUnit
    def set_sizeUnit(self, sizeUnit): self.sizeUnit = sizeUnit
    def get_readThroughputValue(self): return self.readThroughputValue
    def set_readThroughputValue(self, readThroughputValue): self.readThroughputValue = readThroughputValue
    def get_readThroughputUnit(self): return self.readThroughputUnit
    def set_readThroughputUnit(self, readThroughputUnit): self.readThroughputUnit = readThroughputUnit
    def get_readLatencyValue(self): return self.readLatencyValue
    def set_readLatencyValue(self, readLatencyValue): self.readLatencyValue = readLatencyValue
    def get_readLatencyUnit(self): return self.readLatencyUnit
    def set_readLatencyUnit(self, readLatencyUnit): self.readLatencyUnit = readLatencyUnit
    def get_writeThroughputValue(self): return self.writeThroughputValue
    def set_writeThroughputValue(self, writeThroughputValue): self.writeThroughputValue = writeThroughputValue
    def get_writeThroughputUnit(self): return self.writeThroughputUnit
    def set_writeThroughputUnit(self, writeThroughputUnit): self.writeThroughputUnit = writeThroughputUnit
    def get_writeLatencyValue(self): return self.writeLatencyValue
    def set_writeLatencyValue(self, writeLatencyValue): self.writeLatencyValue = writeLatencyValue
    def get_writeLatencyUnit(self): return self.writeLatencyUnit
    def set_writeLatencyUnit(self, writeLatencyUnit): self.writeLatencyUnit = writeLatencyUnit
    def get_frequencyDomain(self): return self.frequencyDomain
    def set_frequencyDomain(self, frequencyDomain): self.frequencyDomain = frequencyDomain
    def get_voltageDomain(self): return self.voltageDomain
    def set_voltageDomain(self, voltageDomain): self.voltageDomain = voltageDomain
    def get_memoryPowerModel(self): return self.memoryPowerModel
    def set_memoryPowerModel(self, memoryPowerModel): self.memoryPowerModel = memoryPowerModel
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_SizeValueType(self, value):
        # Validate type SizeValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on SizeValueType' % {"value" : value} )
    def validate_SizeUnitType(self, value):
        # Validate type SizeUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bit', 'B', 'kB', 'KiB', 'MB', 'MiB', 'GB', 'GiB', 'TB', 'TiB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SizeUnitType' % {"value" : value.encode("utf-8")} )
    def validate_ThroughputValueType(self, value):
        # Validate type ThroughputValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on ThroughputValueType' % {"value" : value} )
    def validate_ThroughputUnitType(self, value):
        # Validate type ThroughputUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bit/cycle', 'B/cycle', 'kB/cycle', 'KiB/cycle']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ThroughputUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CyclesValueType(self, value):
        # Validate type CyclesValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CyclesValueType' % {"value" : value} )
    def validate_CyclesUnitType(self, value):
        # Validate type CyclesUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cycles', 'kcycles', 'Mcycles']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CyclesUnitType' % {"value" : value.encode("utf-8")} )
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='MemoryType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='MemoryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='MemoryType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.sizeValue is not None and 'sizeValue' not in already_processed:
            already_processed.add('sizeValue')
            outfile.write(' sizeValue=%s' % (quote_attrib(self.sizeValue), ))
        if self.sizeUnit is not None and 'sizeUnit' not in already_processed:
            already_processed.add('sizeUnit')
            outfile.write(' sizeUnit=%s' % (quote_attrib(self.sizeUnit), ))
        if self.readThroughputValue is not None and 'readThroughputValue' not in already_processed:
            already_processed.add('readThroughputValue')
            outfile.write(' readThroughputValue=%s' % (quote_attrib(self.readThroughputValue), ))
        if self.readThroughputUnit != "bit/cycle" and 'readThroughputUnit' not in already_processed:
            already_processed.add('readThroughputUnit')
            outfile.write(' readThroughputUnit=%s' % (quote_attrib(self.readThroughputUnit), ))
        if self.readLatencyValue != "0" and 'readLatencyValue' not in already_processed:
            already_processed.add('readLatencyValue')
            outfile.write(' readLatencyValue=%s' % (quote_attrib(self.readLatencyValue), ))
        if self.readLatencyUnit != "cycles" and 'readLatencyUnit' not in already_processed:
            already_processed.add('readLatencyUnit')
            outfile.write(' readLatencyUnit=%s' % (quote_attrib(self.readLatencyUnit), ))
        if self.writeThroughputValue is not None and 'writeThroughputValue' not in already_processed:
            already_processed.add('writeThroughputValue')
            outfile.write(' writeThroughputValue=%s' % (quote_attrib(self.writeThroughputValue), ))
        if self.writeThroughputUnit != "bit/cycle" and 'writeThroughputUnit' not in already_processed:
            already_processed.add('writeThroughputUnit')
            outfile.write(' writeThroughputUnit=%s' % (quote_attrib(self.writeThroughputUnit), ))
        if self.writeLatencyValue != "0" and 'writeLatencyValue' not in already_processed:
            already_processed.add('writeLatencyValue')
            outfile.write(' writeLatencyValue=%s' % (quote_attrib(self.writeLatencyValue), ))
        if self.writeLatencyUnit != "cycles" and 'writeLatencyUnit' not in already_processed:
            already_processed.add('writeLatencyUnit')
            outfile.write(' writeLatencyUnit=%s' % (quote_attrib(self.writeLatencyUnit), ))
        if self.frequencyDomain is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            outfile.write(' frequencyDomain=%s' % (quote_attrib(self.frequencyDomain), ))
        if self.voltageDomain is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            outfile.write(' voltageDomain=%s' % (quote_attrib(self.voltageDomain), ))
        if self.memoryPowerModel is not None and 'memoryPowerModel' not in already_processed:
            already_processed.add('memoryPowerModel')
            outfile.write(' memoryPowerModel=%s' % (quote_attrib(self.memoryPowerModel), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='MemoryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('sizeValue', node)
        if value is not None and 'sizeValue' not in already_processed:
            already_processed.add('sizeValue')
            self.sizeValue = value
            self.validate_SizeValueType(self.sizeValue)    # validate type SizeValueType
        value = find_attr_value_('sizeUnit', node)
        if value is not None and 'sizeUnit' not in already_processed:
            already_processed.add('sizeUnit')
            self.sizeUnit = value
            self.validate_SizeUnitType(self.sizeUnit)    # validate type SizeUnitType
        value = find_attr_value_('readThroughputValue', node)
        if value is not None and 'readThroughputValue' not in already_processed:
            already_processed.add('readThroughputValue')
            self.readThroughputValue = value
            self.validate_ThroughputValueType(self.readThroughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('readThroughputUnit', node)
        if value is not None and 'readThroughputUnit' not in already_processed:
            already_processed.add('readThroughputUnit')
            self.readThroughputUnit = value
            self.validate_ThroughputUnitType(self.readThroughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('readLatencyValue', node)
        if value is not None and 'readLatencyValue' not in already_processed:
            already_processed.add('readLatencyValue')
            self.readLatencyValue = value
            self.validate_CyclesValueType(self.readLatencyValue)    # validate type CyclesValueType
        value = find_attr_value_('readLatencyUnit', node)
        if value is not None and 'readLatencyUnit' not in already_processed:
            already_processed.add('readLatencyUnit')
            self.readLatencyUnit = value
            self.validate_CyclesUnitType(self.readLatencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('writeThroughputValue', node)
        if value is not None and 'writeThroughputValue' not in already_processed:
            already_processed.add('writeThroughputValue')
            self.writeThroughputValue = value
            self.validate_ThroughputValueType(self.writeThroughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('writeThroughputUnit', node)
        if value is not None and 'writeThroughputUnit' not in already_processed:
            already_processed.add('writeThroughputUnit')
            self.writeThroughputUnit = value
            self.validate_ThroughputUnitType(self.writeThroughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('writeLatencyValue', node)
        if value is not None and 'writeLatencyValue' not in already_processed:
            already_processed.add('writeLatencyValue')
            self.writeLatencyValue = value
            self.validate_CyclesValueType(self.writeLatencyValue)    # validate type CyclesValueType
        value = find_attr_value_('writeLatencyUnit', node)
        if value is not None and 'writeLatencyUnit' not in already_processed:
            already_processed.add('writeLatencyUnit')
            self.writeLatencyUnit = value
            self.validate_CyclesUnitType(self.writeLatencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('frequencyDomain', node)
        if value is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            self.frequencyDomain = value
            self.validate_RefType(self.frequencyDomain)    # validate type RefType
        value = find_attr_value_('voltageDomain', node)
        if value is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            self.voltageDomain = value
            self.validate_RefType(self.voltageDomain)    # validate type RefType
        value = find_attr_value_('memoryPowerModel', node)
        if value is not None and 'memoryPowerModel' not in already_processed:
            already_processed.add('memoryPowerModel')
            self.memoryPowerModel = value
            self.validate_RefType(self.memoryPowerModel)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MemoryType


class MemoryRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, memory=None, extensiontype_=None):
        self.original_tagname_ = None
        self.memory = _cast(None, memory)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemoryRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemoryRefType.subclass:
            return MemoryRefType.subclass(*args_, **kwargs_)
        else:
            return MemoryRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_memory(self): return self.memory
    def set_memory(self, memory): self.memory = memory
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='MemoryRefType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemoryRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='MemoryRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='MemoryRefType'):
        if self.memory is not None and 'memory' not in already_processed:
            already_processed.add('memory')
            outfile.write(' memory=%s' % (quote_attrib(self.memory), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='MemoryRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('memory', node)
        if value is not None and 'memory' not in already_processed:
            already_processed.add('memory')
            self.memory = value
            self.validate_RefType(self.memory)    # validate type RefType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MemoryRefType


class MemoryAccessType(MemoryRefType):
    subclass = None
    superclass = MemoryRefType
    def __init__(self, memory=None, access=None):
        self.original_tagname_ = None
        super(MemoryAccessType, self).__init__(memory, )
        self.access = _cast(None, access)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemoryAccessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemoryAccessType.subclass:
            return MemoryAccessType.subclass(*args_, **kwargs_)
        else:
            return MemoryAccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def validate_AccessType(self, value):
        # Validate type AccessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read', 'write']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AccessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(MemoryAccessType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='MemoryAccessType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemoryAccessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='MemoryAccessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='MemoryAccessType'):
        super(MemoryAccessType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MemoryAccessType')
        if self.access is not None and 'access' not in already_processed:
            already_processed.add('access')
            outfile.write(' access=%s' % (quote_attrib(self.access), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='MemoryAccessType', fromsubclass_=False, pretty_print=True):
        super(MemoryAccessType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('access', node)
        if value is not None and 'access' not in already_processed:
            already_processed.add('access')
            self.access = value
            self.validate_AccessType(self.access)    # validate type AccessType
        super(MemoryAccessType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MemoryAccessType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MemoryAccessType


class CachePowerStateType(VoltageFrequencyConditionListType):
    subclass = None
    superclass = VoltageFrequencyConditionListType
    def __init__(self, VoltageCondition=None, FrequencyCondition=None, FrequencyVoltageCondition=None, name=None, powerValue=None, powerUnit='pW'):
        self.original_tagname_ = None
        super(CachePowerStateType, self).__init__(VoltageCondition, FrequencyCondition, FrequencyVoltageCondition, )
        self.name = _cast(None, name)
        self.powerValue = _cast(None, powerValue)
        self.powerUnit = _cast(None, powerUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CachePowerStateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CachePowerStateType.subclass:
            return CachePowerStateType.subclass(*args_, **kwargs_)
        else:
            return CachePowerStateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_powerValue(self): return self.powerValue
    def set_powerValue(self, powerValue): self.powerValue = powerValue
    def get_powerUnit(self): return self.powerUnit
    def set_powerUnit(self, powerUnit): self.powerUnit = powerUnit
    def validate_NameType(self, value):
        # Validate type NameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NameType_patterns_, ))
    validate_NameType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_PowerValueType(self, value):
        # Validate type PowerValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PowerValueType' % {"value" : value} )
    def validate_PowerUnitType(self, value):
        # Validate type PowerUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pW', 'nW', 'uW', 'mW', 'W']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PowerUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(CachePowerStateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CachePowerStateType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CachePowerStateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CachePowerStateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CachePowerStateType'):
        super(CachePowerStateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CachePowerStateType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.powerValue is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            outfile.write(' powerValue=%s' % (quote_attrib(self.powerValue), ))
        if self.powerUnit != "pW" and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            outfile.write(' powerUnit=%s' % (quote_attrib(self.powerUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CachePowerStateType', fromsubclass_=False, pretty_print=True):
        super(CachePowerStateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NameType(self.name)    # validate type NameType
        value = find_attr_value_('powerValue', node)
        if value is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            self.powerValue = value
            self.validate_PowerValueType(self.powerValue)    # validate type PowerValueType
        value = find_attr_value_('powerUnit', node)
        if value is not None and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            self.powerUnit = value
            self.validate_PowerUnitType(self.powerUnit)    # validate type PowerUnitType
        super(CachePowerStateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CachePowerStateType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CachePowerStateType


class CachePowerModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, leakageCurrentValue='0', leakageCurrentUnit='pA', cellLeakageCurrentValue='0', cellLeakageCurrentUnit='pA', switchedCapacitanceValue='0', switchedCapacitanceUnit='pF', cellSwitchedCapacitanceValue='0', cellSwitchedCapacitanceUnit='pF', readHitCapacitanceValue='0', readHitCapacitanceUnit='pF', writeHitCapacitanceValue='0', writeHitCapacitanceUnit='pF', readMissCapacitanceValue='0', readMissCapacitanceUnit='pF', writeMissCapacitanceValue='0', writeMissCapacitanceUnit='pF', CachePowerState=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.leakageCurrentValue = _cast(None, leakageCurrentValue)
        self.leakageCurrentUnit = _cast(None, leakageCurrentUnit)
        self.cellLeakageCurrentValue = _cast(None, cellLeakageCurrentValue)
        self.cellLeakageCurrentUnit = _cast(None, cellLeakageCurrentUnit)
        self.switchedCapacitanceValue = _cast(None, switchedCapacitanceValue)
        self.switchedCapacitanceUnit = _cast(None, switchedCapacitanceUnit)
        self.cellSwitchedCapacitanceValue = _cast(None, cellSwitchedCapacitanceValue)
        self.cellSwitchedCapacitanceUnit = _cast(None, cellSwitchedCapacitanceUnit)
        self.readHitCapacitanceValue = _cast(None, readHitCapacitanceValue)
        self.readHitCapacitanceUnit = _cast(None, readHitCapacitanceUnit)
        self.writeHitCapacitanceValue = _cast(None, writeHitCapacitanceValue)
        self.writeHitCapacitanceUnit = _cast(None, writeHitCapacitanceUnit)
        self.readMissCapacitanceValue = _cast(None, readMissCapacitanceValue)
        self.readMissCapacitanceUnit = _cast(None, readMissCapacitanceUnit)
        self.writeMissCapacitanceValue = _cast(None, writeMissCapacitanceValue)
        self.writeMissCapacitanceUnit = _cast(None, writeMissCapacitanceUnit)
        if CachePowerState is None:
            self.CachePowerState = []
        else:
            self.CachePowerState = CachePowerState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CachePowerModelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CachePowerModelType.subclass:
            return CachePowerModelType.subclass(*args_, **kwargs_)
        else:
            return CachePowerModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CachePowerState(self): return self.CachePowerState
    def set_CachePowerState(self, CachePowerState): self.CachePowerState = CachePowerState
    def add_CachePowerState(self, value): self.CachePowerState.append(value)
    def insert_CachePowerState_at(self, index, value): self.CachePowerState.insert(index, value)
    def replace_CachePowerState_at(self, index, value): self.CachePowerState[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_leakageCurrentValue(self): return self.leakageCurrentValue
    def set_leakageCurrentValue(self, leakageCurrentValue): self.leakageCurrentValue = leakageCurrentValue
    def get_leakageCurrentUnit(self): return self.leakageCurrentUnit
    def set_leakageCurrentUnit(self, leakageCurrentUnit): self.leakageCurrentUnit = leakageCurrentUnit
    def get_cellLeakageCurrentValue(self): return self.cellLeakageCurrentValue
    def set_cellLeakageCurrentValue(self, cellLeakageCurrentValue): self.cellLeakageCurrentValue = cellLeakageCurrentValue
    def get_cellLeakageCurrentUnit(self): return self.cellLeakageCurrentUnit
    def set_cellLeakageCurrentUnit(self, cellLeakageCurrentUnit): self.cellLeakageCurrentUnit = cellLeakageCurrentUnit
    def get_switchedCapacitanceValue(self): return self.switchedCapacitanceValue
    def set_switchedCapacitanceValue(self, switchedCapacitanceValue): self.switchedCapacitanceValue = switchedCapacitanceValue
    def get_switchedCapacitanceUnit(self): return self.switchedCapacitanceUnit
    def set_switchedCapacitanceUnit(self, switchedCapacitanceUnit): self.switchedCapacitanceUnit = switchedCapacitanceUnit
    def get_cellSwitchedCapacitanceValue(self): return self.cellSwitchedCapacitanceValue
    def set_cellSwitchedCapacitanceValue(self, cellSwitchedCapacitanceValue): self.cellSwitchedCapacitanceValue = cellSwitchedCapacitanceValue
    def get_cellSwitchedCapacitanceUnit(self): return self.cellSwitchedCapacitanceUnit
    def set_cellSwitchedCapacitanceUnit(self, cellSwitchedCapacitanceUnit): self.cellSwitchedCapacitanceUnit = cellSwitchedCapacitanceUnit
    def get_readHitCapacitanceValue(self): return self.readHitCapacitanceValue
    def set_readHitCapacitanceValue(self, readHitCapacitanceValue): self.readHitCapacitanceValue = readHitCapacitanceValue
    def get_readHitCapacitanceUnit(self): return self.readHitCapacitanceUnit
    def set_readHitCapacitanceUnit(self, readHitCapacitanceUnit): self.readHitCapacitanceUnit = readHitCapacitanceUnit
    def get_writeHitCapacitanceValue(self): return self.writeHitCapacitanceValue
    def set_writeHitCapacitanceValue(self, writeHitCapacitanceValue): self.writeHitCapacitanceValue = writeHitCapacitanceValue
    def get_writeHitCapacitanceUnit(self): return self.writeHitCapacitanceUnit
    def set_writeHitCapacitanceUnit(self, writeHitCapacitanceUnit): self.writeHitCapacitanceUnit = writeHitCapacitanceUnit
    def get_readMissCapacitanceValue(self): return self.readMissCapacitanceValue
    def set_readMissCapacitanceValue(self, readMissCapacitanceValue): self.readMissCapacitanceValue = readMissCapacitanceValue
    def get_readMissCapacitanceUnit(self): return self.readMissCapacitanceUnit
    def set_readMissCapacitanceUnit(self, readMissCapacitanceUnit): self.readMissCapacitanceUnit = readMissCapacitanceUnit
    def get_writeMissCapacitanceValue(self): return self.writeMissCapacitanceValue
    def set_writeMissCapacitanceValue(self, writeMissCapacitanceValue): self.writeMissCapacitanceValue = writeMissCapacitanceValue
    def get_writeMissCapacitanceUnit(self): return self.writeMissCapacitanceUnit
    def set_writeMissCapacitanceUnit(self, writeMissCapacitanceUnit): self.writeMissCapacitanceUnit = writeMissCapacitanceUnit
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_CurrentValueType(self, value):
        # Validate type CurrentValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CurrentValueType' % {"value" : value} )
    def validate_CurrentUnitType(self, value):
        # Validate type CurrentUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pA', 'nA', 'uA', 'mA', 'A']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CurrentUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CapacitanceValueType(self, value):
        # Validate type CapacitanceValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CapacitanceValueType' % {"value" : value} )
    def validate_CapacitanceUnitType(self, value):
        # Validate type CapacitanceUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fF', 'pF', 'nF', 'uF', 'mF', 'F']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CapacitanceUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CachePowerState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CachePowerModelType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CachePowerModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CachePowerModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CachePowerModelType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.leakageCurrentValue != "0" and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            outfile.write(' leakageCurrentValue=%s' % (quote_attrib(self.leakageCurrentValue), ))
        if self.leakageCurrentUnit != "pA" and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            outfile.write(' leakageCurrentUnit=%s' % (quote_attrib(self.leakageCurrentUnit), ))
        if self.cellLeakageCurrentValue != "0" and 'cellLeakageCurrentValue' not in already_processed:
            already_processed.add('cellLeakageCurrentValue')
            outfile.write(' cellLeakageCurrentValue=%s' % (quote_attrib(self.cellLeakageCurrentValue), ))
        if self.cellLeakageCurrentUnit != "pA" and 'cellLeakageCurrentUnit' not in already_processed:
            already_processed.add('cellLeakageCurrentUnit')
            outfile.write(' cellLeakageCurrentUnit=%s' % (quote_attrib(self.cellLeakageCurrentUnit), ))
        if self.switchedCapacitanceValue != "0" and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            outfile.write(' switchedCapacitanceValue=%s' % (quote_attrib(self.switchedCapacitanceValue), ))
        if self.switchedCapacitanceUnit != "pF" and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            outfile.write(' switchedCapacitanceUnit=%s' % (quote_attrib(self.switchedCapacitanceUnit), ))
        if self.cellSwitchedCapacitanceValue != "0" and 'cellSwitchedCapacitanceValue' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceValue')
            outfile.write(' cellSwitchedCapacitanceValue=%s' % (quote_attrib(self.cellSwitchedCapacitanceValue), ))
        if self.cellSwitchedCapacitanceUnit != "pF" and 'cellSwitchedCapacitanceUnit' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceUnit')
            outfile.write(' cellSwitchedCapacitanceUnit=%s' % (quote_attrib(self.cellSwitchedCapacitanceUnit), ))
        if self.readHitCapacitanceValue != "0" and 'readHitCapacitanceValue' not in already_processed:
            already_processed.add('readHitCapacitanceValue')
            outfile.write(' readHitCapacitanceValue=%s' % (quote_attrib(self.readHitCapacitanceValue), ))
        if self.readHitCapacitanceUnit != "pF" and 'readHitCapacitanceUnit' not in already_processed:
            already_processed.add('readHitCapacitanceUnit')
            outfile.write(' readHitCapacitanceUnit=%s' % (quote_attrib(self.readHitCapacitanceUnit), ))
        if self.writeHitCapacitanceValue != "0" and 'writeHitCapacitanceValue' not in already_processed:
            already_processed.add('writeHitCapacitanceValue')
            outfile.write(' writeHitCapacitanceValue=%s' % (quote_attrib(self.writeHitCapacitanceValue), ))
        if self.writeHitCapacitanceUnit != "pF" and 'writeHitCapacitanceUnit' not in already_processed:
            already_processed.add('writeHitCapacitanceUnit')
            outfile.write(' writeHitCapacitanceUnit=%s' % (quote_attrib(self.writeHitCapacitanceUnit), ))
        if self.readMissCapacitanceValue != "0" and 'readMissCapacitanceValue' not in already_processed:
            already_processed.add('readMissCapacitanceValue')
            outfile.write(' readMissCapacitanceValue=%s' % (quote_attrib(self.readMissCapacitanceValue), ))
        if self.readMissCapacitanceUnit != "pF" and 'readMissCapacitanceUnit' not in already_processed:
            already_processed.add('readMissCapacitanceUnit')
            outfile.write(' readMissCapacitanceUnit=%s' % (quote_attrib(self.readMissCapacitanceUnit), ))
        if self.writeMissCapacitanceValue != "0" and 'writeMissCapacitanceValue' not in already_processed:
            already_processed.add('writeMissCapacitanceValue')
            outfile.write(' writeMissCapacitanceValue=%s' % (quote_attrib(self.writeMissCapacitanceValue), ))
        if self.writeMissCapacitanceUnit != "pF" and 'writeMissCapacitanceUnit' not in already_processed:
            already_processed.add('writeMissCapacitanceUnit')
            outfile.write(' writeMissCapacitanceUnit=%s' % (quote_attrib(self.writeMissCapacitanceUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CachePowerModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CachePowerState_ in self.CachePowerState:
            CachePowerState_.export(outfile, level, namespace_, name_='CachePowerState', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('leakageCurrentValue', node)
        if value is not None and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            self.leakageCurrentValue = value
            self.validate_CurrentValueType(self.leakageCurrentValue)    # validate type CurrentValueType
        value = find_attr_value_('leakageCurrentUnit', node)
        if value is not None and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            self.leakageCurrentUnit = value
            self.validate_CurrentUnitType(self.leakageCurrentUnit)    # validate type CurrentUnitType
        value = find_attr_value_('cellLeakageCurrentValue', node)
        if value is not None and 'cellLeakageCurrentValue' not in already_processed:
            already_processed.add('cellLeakageCurrentValue')
            self.cellLeakageCurrentValue = value
            self.validate_CurrentValueType(self.cellLeakageCurrentValue)    # validate type CurrentValueType
        value = find_attr_value_('cellLeakageCurrentUnit', node)
        if value is not None and 'cellLeakageCurrentUnit' not in already_processed:
            already_processed.add('cellLeakageCurrentUnit')
            self.cellLeakageCurrentUnit = value
            self.validate_CurrentUnitType(self.cellLeakageCurrentUnit)    # validate type CurrentUnitType
        value = find_attr_value_('switchedCapacitanceValue', node)
        if value is not None and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            self.switchedCapacitanceValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceUnit', node)
        if value is not None and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            self.switchedCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('cellSwitchedCapacitanceValue', node)
        if value is not None and 'cellSwitchedCapacitanceValue' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceValue')
            self.cellSwitchedCapacitanceValue = value
            self.validate_CapacitanceValueType(self.cellSwitchedCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('cellSwitchedCapacitanceUnit', node)
        if value is not None and 'cellSwitchedCapacitanceUnit' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceUnit')
            self.cellSwitchedCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.cellSwitchedCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('readHitCapacitanceValue', node)
        if value is not None and 'readHitCapacitanceValue' not in already_processed:
            already_processed.add('readHitCapacitanceValue')
            self.readHitCapacitanceValue = value
            self.validate_CapacitanceValueType(self.readHitCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('readHitCapacitanceUnit', node)
        if value is not None and 'readHitCapacitanceUnit' not in already_processed:
            already_processed.add('readHitCapacitanceUnit')
            self.readHitCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.readHitCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('writeHitCapacitanceValue', node)
        if value is not None and 'writeHitCapacitanceValue' not in already_processed:
            already_processed.add('writeHitCapacitanceValue')
            self.writeHitCapacitanceValue = value
            self.validate_CapacitanceValueType(self.writeHitCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('writeHitCapacitanceUnit', node)
        if value is not None and 'writeHitCapacitanceUnit' not in already_processed:
            already_processed.add('writeHitCapacitanceUnit')
            self.writeHitCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.writeHitCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('readMissCapacitanceValue', node)
        if value is not None and 'readMissCapacitanceValue' not in already_processed:
            already_processed.add('readMissCapacitanceValue')
            self.readMissCapacitanceValue = value
            self.validate_CapacitanceValueType(self.readMissCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('readMissCapacitanceUnit', node)
        if value is not None and 'readMissCapacitanceUnit' not in already_processed:
            already_processed.add('readMissCapacitanceUnit')
            self.readMissCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.readMissCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('writeMissCapacitanceValue', node)
        if value is not None and 'writeMissCapacitanceValue' not in already_processed:
            already_processed.add('writeMissCapacitanceValue')
            self.writeMissCapacitanceValue = value
            self.validate_CapacitanceValueType(self.writeMissCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('writeMissCapacitanceUnit', node)
        if value is not None and 'writeMissCapacitanceUnit' not in already_processed:
            already_processed.add('writeMissCapacitanceUnit')
            self.writeMissCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.writeMissCapacitanceUnit)    # validate type CapacitanceUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CachePowerState':
            obj_ = CachePowerStateType.factory()
            obj_.build(child_)
            self.CachePowerState.append(obj_)
            obj_.original_tagname_ = 'CachePowerState'
# end class CachePowerModelType


class CacheType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, coherency=None, sizeValue=None, sizeUnit=None, lineSizeValue=None, lineSizeUnit=None, ways=None, replacement=None, prefetch=None, prefetchDistance=None, writeAllocate=None, writeBack=None, readHitThroughputValue=None, readHitThroughputUnit='bit/cycle', readHitLatencyValue='0', readHitLatencyUnit='cycles', writeHitThroughputValue=None, writeHitThroughputUnit='bit/cycle', writeHitLatencyValue='0', writeHitLatencyUnit='cycles', readMissThroughputValue=None, readMissThroughputUnit='bit/cycle', readMissLatencyValue='0', readMissLatencyUnit='cycles', writeMissThroughputValue=None, writeMissThroughputUnit='bit/cycle', writeMissLatencyValue='0', writeMissLatencyUnit='cycles', frequencyDomain=None, voltageDomain=None, cachePowerModel=None, ParentCacheRef=None, ParentMemoryRef=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.coherency = _cast(None, coherency)
        self.sizeValue = _cast(None, sizeValue)
        self.sizeUnit = _cast(None, sizeUnit)
        self.lineSizeValue = _cast(None, lineSizeValue)
        self.lineSizeUnit = _cast(None, lineSizeUnit)
        self.ways = _cast(None, ways)
        self.replacement = _cast(None, replacement)
        self.prefetch = _cast(None, prefetch)
        self.prefetchDistance = _cast(int, prefetchDistance)
        self.writeAllocate = _cast(None, writeAllocate)
        self.writeBack = _cast(None, writeBack)
        self.readHitThroughputValue = _cast(None, readHitThroughputValue)
        self.readHitThroughputUnit = _cast(None, readHitThroughputUnit)
        self.readHitLatencyValue = _cast(None, readHitLatencyValue)
        self.readHitLatencyUnit = _cast(None, readHitLatencyUnit)
        self.writeHitThroughputValue = _cast(None, writeHitThroughputValue)
        self.writeHitThroughputUnit = _cast(None, writeHitThroughputUnit)
        self.writeHitLatencyValue = _cast(None, writeHitLatencyValue)
        self.writeHitLatencyUnit = _cast(None, writeHitLatencyUnit)
        self.readMissThroughputValue = _cast(None, readMissThroughputValue)
        self.readMissThroughputUnit = _cast(None, readMissThroughputUnit)
        self.readMissLatencyValue = _cast(None, readMissLatencyValue)
        self.readMissLatencyUnit = _cast(None, readMissLatencyUnit)
        self.writeMissThroughputValue = _cast(None, writeMissThroughputValue)
        self.writeMissThroughputUnit = _cast(None, writeMissThroughputUnit)
        self.writeMissLatencyValue = _cast(None, writeMissLatencyValue)
        self.writeMissLatencyUnit = _cast(None, writeMissLatencyUnit)
        self.frequencyDomain = _cast(None, frequencyDomain)
        self.voltageDomain = _cast(None, voltageDomain)
        self.cachePowerModel = _cast(None, cachePowerModel)
        self.ParentCacheRef = ParentCacheRef
        self.ParentMemoryRef = ParentMemoryRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CacheType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CacheType.subclass:
            return CacheType.subclass(*args_, **kwargs_)
        else:
            return CacheType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParentCacheRef(self): return self.ParentCacheRef
    def set_ParentCacheRef(self, ParentCacheRef): self.ParentCacheRef = ParentCacheRef
    def get_ParentMemoryRef(self): return self.ParentMemoryRef
    def set_ParentMemoryRef(self, ParentMemoryRef): self.ParentMemoryRef = ParentMemoryRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_coherency(self): return self.coherency
    def set_coherency(self, coherency): self.coherency = coherency
    def get_sizeValue(self): return self.sizeValue
    def set_sizeValue(self, sizeValue): self.sizeValue = sizeValue
    def get_sizeUnit(self): return self.sizeUnit
    def set_sizeUnit(self, sizeUnit): self.sizeUnit = sizeUnit
    def get_lineSizeValue(self): return self.lineSizeValue
    def set_lineSizeValue(self, lineSizeValue): self.lineSizeValue = lineSizeValue
    def get_lineSizeUnit(self): return self.lineSizeUnit
    def set_lineSizeUnit(self, lineSizeUnit): self.lineSizeUnit = lineSizeUnit
    def get_ways(self): return self.ways
    def set_ways(self, ways): self.ways = ways
    def get_replacement(self): return self.replacement
    def set_replacement(self, replacement): self.replacement = replacement
    def get_prefetch(self): return self.prefetch
    def set_prefetch(self, prefetch): self.prefetch = prefetch
    def get_prefetchDistance(self): return self.prefetchDistance
    def set_prefetchDistance(self, prefetchDistance): self.prefetchDistance = prefetchDistance
    def get_writeAllocate(self): return self.writeAllocate
    def set_writeAllocate(self, writeAllocate): self.writeAllocate = writeAllocate
    def get_writeBack(self): return self.writeBack
    def set_writeBack(self, writeBack): self.writeBack = writeBack
    def get_readHitThroughputValue(self): return self.readHitThroughputValue
    def set_readHitThroughputValue(self, readHitThroughputValue): self.readHitThroughputValue = readHitThroughputValue
    def get_readHitThroughputUnit(self): return self.readHitThroughputUnit
    def set_readHitThroughputUnit(self, readHitThroughputUnit): self.readHitThroughputUnit = readHitThroughputUnit
    def get_readHitLatencyValue(self): return self.readHitLatencyValue
    def set_readHitLatencyValue(self, readHitLatencyValue): self.readHitLatencyValue = readHitLatencyValue
    def get_readHitLatencyUnit(self): return self.readHitLatencyUnit
    def set_readHitLatencyUnit(self, readHitLatencyUnit): self.readHitLatencyUnit = readHitLatencyUnit
    def get_writeHitThroughputValue(self): return self.writeHitThroughputValue
    def set_writeHitThroughputValue(self, writeHitThroughputValue): self.writeHitThroughputValue = writeHitThroughputValue
    def get_writeHitThroughputUnit(self): return self.writeHitThroughputUnit
    def set_writeHitThroughputUnit(self, writeHitThroughputUnit): self.writeHitThroughputUnit = writeHitThroughputUnit
    def get_writeHitLatencyValue(self): return self.writeHitLatencyValue
    def set_writeHitLatencyValue(self, writeHitLatencyValue): self.writeHitLatencyValue = writeHitLatencyValue
    def get_writeHitLatencyUnit(self): return self.writeHitLatencyUnit
    def set_writeHitLatencyUnit(self, writeHitLatencyUnit): self.writeHitLatencyUnit = writeHitLatencyUnit
    def get_readMissThroughputValue(self): return self.readMissThroughputValue
    def set_readMissThroughputValue(self, readMissThroughputValue): self.readMissThroughputValue = readMissThroughputValue
    def get_readMissThroughputUnit(self): return self.readMissThroughputUnit
    def set_readMissThroughputUnit(self, readMissThroughputUnit): self.readMissThroughputUnit = readMissThroughputUnit
    def get_readMissLatencyValue(self): return self.readMissLatencyValue
    def set_readMissLatencyValue(self, readMissLatencyValue): self.readMissLatencyValue = readMissLatencyValue
    def get_readMissLatencyUnit(self): return self.readMissLatencyUnit
    def set_readMissLatencyUnit(self, readMissLatencyUnit): self.readMissLatencyUnit = readMissLatencyUnit
    def get_writeMissThroughputValue(self): return self.writeMissThroughputValue
    def set_writeMissThroughputValue(self, writeMissThroughputValue): self.writeMissThroughputValue = writeMissThroughputValue
    def get_writeMissThroughputUnit(self): return self.writeMissThroughputUnit
    def set_writeMissThroughputUnit(self, writeMissThroughputUnit): self.writeMissThroughputUnit = writeMissThroughputUnit
    def get_writeMissLatencyValue(self): return self.writeMissLatencyValue
    def set_writeMissLatencyValue(self, writeMissLatencyValue): self.writeMissLatencyValue = writeMissLatencyValue
    def get_writeMissLatencyUnit(self): return self.writeMissLatencyUnit
    def set_writeMissLatencyUnit(self, writeMissLatencyUnit): self.writeMissLatencyUnit = writeMissLatencyUnit
    def get_frequencyDomain(self): return self.frequencyDomain
    def set_frequencyDomain(self, frequencyDomain): self.frequencyDomain = frequencyDomain
    def get_voltageDomain(self): return self.voltageDomain
    def set_voltageDomain(self, voltageDomain): self.voltageDomain = voltageDomain
    def get_cachePowerModel(self): return self.cachePowerModel
    def set_cachePowerModel(self, cachePowerModel): self.cachePowerModel = cachePowerModel
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_CoherencyType(self, value):
        # Validate type CoherencyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['hard', 'soft', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CoherencyType' % {"value" : value.encode("utf-8")} )
    def validate_SizeValueType(self, value):
        # Validate type SizeValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on SizeValueType' % {"value" : value} )
    def validate_SizeUnitType(self, value):
        # Validate type SizeUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bit', 'B', 'kB', 'KiB', 'MB', 'MiB', 'GB', 'GiB', 'TB', 'TiB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SizeUnitType' % {"value" : value.encode("utf-8")} )
    def validate_PositiveIntType(self, value):
        # Validate type PositiveIntType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ReplacementType(self, value):
        # Validate type ReplacementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['lru', 'fifo', 'random']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReplacementType' % {"value" : value.encode("utf-8")} )
    def validate_PrefetchType(self, value):
        # Validate type PrefetchType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['always', 'never', 'miss', 'once']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PrefetchType' % {"value" : value.encode("utf-8")} )
    def validate_WriteAllocateType(self, value):
        # Validate type WriteAllocateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['always', 'never', 'noFetch']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WriteAllocateType' % {"value" : value.encode("utf-8")} )
    def validate_WriteBackType(self, value):
        # Validate type WriteBackType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['always', 'never', 'noFetch']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WriteBackType' % {"value" : value.encode("utf-8")} )
    def validate_ThroughputValueType(self, value):
        # Validate type ThroughputValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on ThroughputValueType' % {"value" : value} )
    def validate_ThroughputUnitType(self, value):
        # Validate type ThroughputUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bit/cycle', 'B/cycle', 'kB/cycle', 'KiB/cycle']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ThroughputUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CyclesValueType(self, value):
        # Validate type CyclesValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CyclesValueType' % {"value" : value} )
    def validate_CyclesUnitType(self, value):
        # Validate type CyclesUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cycles', 'kcycles', 'Mcycles']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CyclesUnitType' % {"value" : value.encode("utf-8")} )
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (
            self.ParentCacheRef is not None or
            self.ParentMemoryRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CacheType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CacheType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CacheType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CacheType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.coherency is not None and 'coherency' not in already_processed:
            already_processed.add('coherency')
            outfile.write(' coherency=%s' % (quote_attrib(self.coherency), ))
        if self.sizeValue is not None and 'sizeValue' not in already_processed:
            already_processed.add('sizeValue')
            outfile.write(' sizeValue=%s' % (quote_attrib(self.sizeValue), ))
        if self.sizeUnit is not None and 'sizeUnit' not in already_processed:
            already_processed.add('sizeUnit')
            outfile.write(' sizeUnit=%s' % (quote_attrib(self.sizeUnit), ))
        if self.lineSizeValue is not None and 'lineSizeValue' not in already_processed:
            already_processed.add('lineSizeValue')
            outfile.write(' lineSizeValue=%s' % (quote_attrib(self.lineSizeValue), ))
        if self.lineSizeUnit is not None and 'lineSizeUnit' not in already_processed:
            already_processed.add('lineSizeUnit')
            outfile.write(' lineSizeUnit=%s' % (quote_attrib(self.lineSizeUnit), ))
        if self.ways is not None and 'ways' not in already_processed:
            already_processed.add('ways')
            outfile.write(' ways=%s' % (quote_attrib(self.ways), ))
        if self.replacement is not None and 'replacement' not in already_processed:
            already_processed.add('replacement')
            outfile.write(' replacement=%s' % (quote_attrib(self.replacement), ))
        if self.prefetch is not None and 'prefetch' not in already_processed:
            already_processed.add('prefetch')
            outfile.write(' prefetch=%s' % (quote_attrib(self.prefetch), ))
        if self.prefetchDistance is not None and 'prefetchDistance' not in already_processed:
            already_processed.add('prefetchDistance')
            outfile.write(' prefetchDistance="%s"' % self.gds_format_integer(self.prefetchDistance, input_name='prefetchDistance'))
        if self.writeAllocate is not None and 'writeAllocate' not in already_processed:
            already_processed.add('writeAllocate')
            outfile.write(' writeAllocate=%s' % (quote_attrib(self.writeAllocate), ))
        if self.writeBack is not None and 'writeBack' not in already_processed:
            already_processed.add('writeBack')
            outfile.write(' writeBack=%s' % (quote_attrib(self.writeBack), ))
        if self.readHitThroughputValue is not None and 'readHitThroughputValue' not in already_processed:
            already_processed.add('readHitThroughputValue')
            outfile.write(' readHitThroughputValue=%s' % (quote_attrib(self.readHitThroughputValue), ))
        if self.readHitThroughputUnit != "bit/cycle" and 'readHitThroughputUnit' not in already_processed:
            already_processed.add('readHitThroughputUnit')
            outfile.write(' readHitThroughputUnit=%s' % (quote_attrib(self.readHitThroughputUnit), ))
        if self.readHitLatencyValue != "0" and 'readHitLatencyValue' not in already_processed:
            already_processed.add('readHitLatencyValue')
            outfile.write(' readHitLatencyValue=%s' % (quote_attrib(self.readHitLatencyValue), ))
        if self.readHitLatencyUnit != "cycles" and 'readHitLatencyUnit' not in already_processed:
            already_processed.add('readHitLatencyUnit')
            outfile.write(' readHitLatencyUnit=%s' % (quote_attrib(self.readHitLatencyUnit), ))
        if self.writeHitThroughputValue is not None and 'writeHitThroughputValue' not in already_processed:
            already_processed.add('writeHitThroughputValue')
            outfile.write(' writeHitThroughputValue=%s' % (quote_attrib(self.writeHitThroughputValue), ))
        if self.writeHitThroughputUnit != "bit/cycle" and 'writeHitThroughputUnit' not in already_processed:
            already_processed.add('writeHitThroughputUnit')
            outfile.write(' writeHitThroughputUnit=%s' % (quote_attrib(self.writeHitThroughputUnit), ))
        if self.writeHitLatencyValue != "0" and 'writeHitLatencyValue' not in already_processed:
            already_processed.add('writeHitLatencyValue')
            outfile.write(' writeHitLatencyValue=%s' % (quote_attrib(self.writeHitLatencyValue), ))
        if self.writeHitLatencyUnit != "cycles" and 'writeHitLatencyUnit' not in already_processed:
            already_processed.add('writeHitLatencyUnit')
            outfile.write(' writeHitLatencyUnit=%s' % (quote_attrib(self.writeHitLatencyUnit), ))
        if self.readMissThroughputValue is not None and 'readMissThroughputValue' not in already_processed:
            already_processed.add('readMissThroughputValue')
            outfile.write(' readMissThroughputValue=%s' % (quote_attrib(self.readMissThroughputValue), ))
        if self.readMissThroughputUnit != "bit/cycle" and 'readMissThroughputUnit' not in already_processed:
            already_processed.add('readMissThroughputUnit')
            outfile.write(' readMissThroughputUnit=%s' % (quote_attrib(self.readMissThroughputUnit), ))
        if self.readMissLatencyValue != "0" and 'readMissLatencyValue' not in already_processed:
            already_processed.add('readMissLatencyValue')
            outfile.write(' readMissLatencyValue=%s' % (quote_attrib(self.readMissLatencyValue), ))
        if self.readMissLatencyUnit != "cycles" and 'readMissLatencyUnit' not in already_processed:
            already_processed.add('readMissLatencyUnit')
            outfile.write(' readMissLatencyUnit=%s' % (quote_attrib(self.readMissLatencyUnit), ))
        if self.writeMissThroughputValue is not None and 'writeMissThroughputValue' not in already_processed:
            already_processed.add('writeMissThroughputValue')
            outfile.write(' writeMissThroughputValue=%s' % (quote_attrib(self.writeMissThroughputValue), ))
        if self.writeMissThroughputUnit != "bit/cycle" and 'writeMissThroughputUnit' not in already_processed:
            already_processed.add('writeMissThroughputUnit')
            outfile.write(' writeMissThroughputUnit=%s' % (quote_attrib(self.writeMissThroughputUnit), ))
        if self.writeMissLatencyValue != "0" and 'writeMissLatencyValue' not in already_processed:
            already_processed.add('writeMissLatencyValue')
            outfile.write(' writeMissLatencyValue=%s' % (quote_attrib(self.writeMissLatencyValue), ))
        if self.writeMissLatencyUnit != "cycles" and 'writeMissLatencyUnit' not in already_processed:
            already_processed.add('writeMissLatencyUnit')
            outfile.write(' writeMissLatencyUnit=%s' % (quote_attrib(self.writeMissLatencyUnit), ))
        if self.frequencyDomain is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            outfile.write(' frequencyDomain=%s' % (quote_attrib(self.frequencyDomain), ))
        if self.voltageDomain is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            outfile.write(' voltageDomain=%s' % (quote_attrib(self.voltageDomain), ))
        if self.cachePowerModel is not None and 'cachePowerModel' not in already_processed:
            already_processed.add('cachePowerModel')
            outfile.write(' cachePowerModel=%s' % (quote_attrib(self.cachePowerModel), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CacheType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParentCacheRef is not None:
            self.ParentCacheRef.export(outfile, level, namespace_, name_='ParentCacheRef', pretty_print=pretty_print)
        if self.ParentMemoryRef is not None:
            self.ParentMemoryRef.export(outfile, level, namespace_, name_='ParentMemoryRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('coherency', node)
        if value is not None and 'coherency' not in already_processed:
            already_processed.add('coherency')
            self.coherency = value
            self.validate_CoherencyType(self.coherency)    # validate type CoherencyType
        value = find_attr_value_('sizeValue', node)
        if value is not None and 'sizeValue' not in already_processed:
            already_processed.add('sizeValue')
            self.sizeValue = value
            self.validate_SizeValueType(self.sizeValue)    # validate type SizeValueType
        value = find_attr_value_('sizeUnit', node)
        if value is not None and 'sizeUnit' not in already_processed:
            already_processed.add('sizeUnit')
            self.sizeUnit = value
            self.validate_SizeUnitType(self.sizeUnit)    # validate type SizeUnitType
        value = find_attr_value_('lineSizeValue', node)
        if value is not None and 'lineSizeValue' not in already_processed:
            already_processed.add('lineSizeValue')
            self.lineSizeValue = value
            self.validate_SizeValueType(self.lineSizeValue)    # validate type SizeValueType
        value = find_attr_value_('lineSizeUnit', node)
        if value is not None and 'lineSizeUnit' not in already_processed:
            already_processed.add('lineSizeUnit')
            self.lineSizeUnit = value
            self.validate_SizeUnitType(self.lineSizeUnit)    # validate type SizeUnitType
        value = find_attr_value_('ways', node)
        if value is not None and 'ways' not in already_processed:
            already_processed.add('ways')
            try:
                self.ways = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ways <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveIntType(self.ways)    # validate type PositiveIntType
        value = find_attr_value_('replacement', node)
        if value is not None and 'replacement' not in already_processed:
            already_processed.add('replacement')
            self.replacement = value
            self.validate_ReplacementType(self.replacement)    # validate type ReplacementType
        value = find_attr_value_('prefetch', node)
        if value is not None and 'prefetch' not in already_processed:
            already_processed.add('prefetch')
            self.prefetch = value
            self.validate_PrefetchType(self.prefetch)    # validate type PrefetchType
        value = find_attr_value_('prefetchDistance', node)
        if value is not None and 'prefetchDistance' not in already_processed:
            already_processed.add('prefetchDistance')
            try:
                self.prefetchDistance = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.prefetchDistance <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('writeAllocate', node)
        if value is not None and 'writeAllocate' not in already_processed:
            already_processed.add('writeAllocate')
            self.writeAllocate = value
            self.validate_WriteAllocateType(self.writeAllocate)    # validate type WriteAllocateType
        value = find_attr_value_('writeBack', node)
        if value is not None and 'writeBack' not in already_processed:
            already_processed.add('writeBack')
            self.writeBack = value
            self.validate_WriteBackType(self.writeBack)    # validate type WriteBackType
        value = find_attr_value_('readHitThroughputValue', node)
        if value is not None and 'readHitThroughputValue' not in already_processed:
            already_processed.add('readHitThroughputValue')
            self.readHitThroughputValue = value
            self.validate_ThroughputValueType(self.readHitThroughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('readHitThroughputUnit', node)
        if value is not None and 'readHitThroughputUnit' not in already_processed:
            already_processed.add('readHitThroughputUnit')
            self.readHitThroughputUnit = value
            self.validate_ThroughputUnitType(self.readHitThroughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('readHitLatencyValue', node)
        if value is not None and 'readHitLatencyValue' not in already_processed:
            already_processed.add('readHitLatencyValue')
            self.readHitLatencyValue = value
            self.validate_CyclesValueType(self.readHitLatencyValue)    # validate type CyclesValueType
        value = find_attr_value_('readHitLatencyUnit', node)
        if value is not None and 'readHitLatencyUnit' not in already_processed:
            already_processed.add('readHitLatencyUnit')
            self.readHitLatencyUnit = value
            self.validate_CyclesUnitType(self.readHitLatencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('writeHitThroughputValue', node)
        if value is not None and 'writeHitThroughputValue' not in already_processed:
            already_processed.add('writeHitThroughputValue')
            self.writeHitThroughputValue = value
            self.validate_ThroughputValueType(self.writeHitThroughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('writeHitThroughputUnit', node)
        if value is not None and 'writeHitThroughputUnit' not in already_processed:
            already_processed.add('writeHitThroughputUnit')
            self.writeHitThroughputUnit = value
            self.validate_ThroughputUnitType(self.writeHitThroughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('writeHitLatencyValue', node)
        if value is not None and 'writeHitLatencyValue' not in already_processed:
            already_processed.add('writeHitLatencyValue')
            self.writeHitLatencyValue = value
            self.validate_CyclesValueType(self.writeHitLatencyValue)    # validate type CyclesValueType
        value = find_attr_value_('writeHitLatencyUnit', node)
        if value is not None and 'writeHitLatencyUnit' not in already_processed:
            already_processed.add('writeHitLatencyUnit')
            self.writeHitLatencyUnit = value
            self.validate_CyclesUnitType(self.writeHitLatencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('readMissThroughputValue', node)
        if value is not None and 'readMissThroughputValue' not in already_processed:
            already_processed.add('readMissThroughputValue')
            self.readMissThroughputValue = value
            self.validate_ThroughputValueType(self.readMissThroughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('readMissThroughputUnit', node)
        if value is not None and 'readMissThroughputUnit' not in already_processed:
            already_processed.add('readMissThroughputUnit')
            self.readMissThroughputUnit = value
            self.validate_ThroughputUnitType(self.readMissThroughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('readMissLatencyValue', node)
        if value is not None and 'readMissLatencyValue' not in already_processed:
            already_processed.add('readMissLatencyValue')
            self.readMissLatencyValue = value
            self.validate_CyclesValueType(self.readMissLatencyValue)    # validate type CyclesValueType
        value = find_attr_value_('readMissLatencyUnit', node)
        if value is not None and 'readMissLatencyUnit' not in already_processed:
            already_processed.add('readMissLatencyUnit')
            self.readMissLatencyUnit = value
            self.validate_CyclesUnitType(self.readMissLatencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('writeMissThroughputValue', node)
        if value is not None and 'writeMissThroughputValue' not in already_processed:
            already_processed.add('writeMissThroughputValue')
            self.writeMissThroughputValue = value
            self.validate_ThroughputValueType(self.writeMissThroughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('writeMissThroughputUnit', node)
        if value is not None and 'writeMissThroughputUnit' not in already_processed:
            already_processed.add('writeMissThroughputUnit')
            self.writeMissThroughputUnit = value
            self.validate_ThroughputUnitType(self.writeMissThroughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('writeMissLatencyValue', node)
        if value is not None and 'writeMissLatencyValue' not in already_processed:
            already_processed.add('writeMissLatencyValue')
            self.writeMissLatencyValue = value
            self.validate_CyclesValueType(self.writeMissLatencyValue)    # validate type CyclesValueType
        value = find_attr_value_('writeMissLatencyUnit', node)
        if value is not None and 'writeMissLatencyUnit' not in already_processed:
            already_processed.add('writeMissLatencyUnit')
            self.writeMissLatencyUnit = value
            self.validate_CyclesUnitType(self.writeMissLatencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('frequencyDomain', node)
        if value is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            self.frequencyDomain = value
            self.validate_RefType(self.frequencyDomain)    # validate type RefType
        value = find_attr_value_('voltageDomain', node)
        if value is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            self.voltageDomain = value
            self.validate_RefType(self.voltageDomain)    # validate type RefType
        value = find_attr_value_('cachePowerModel', node)
        if value is not None and 'cachePowerModel' not in already_processed:
            already_processed.add('cachePowerModel')
            self.cachePowerModel = value
            self.validate_RefType(self.cachePowerModel)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ParentCacheRef':
            class_obj_ = self.get_class_obj_(child_, CacheRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ParentCacheRef = obj_
            obj_.original_tagname_ = 'ParentCacheRef'
        elif nodeName_ == 'ParentMemoryRef':
            class_obj_ = self.get_class_obj_(child_, MemoryRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ParentMemoryRef = obj_
            obj_.original_tagname_ = 'ParentMemoryRef'
# end class CacheType


class CacheRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cache=None, extensiontype_=None):
        self.original_tagname_ = None
        self.cache = _cast(None, cache)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CacheRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CacheRefType.subclass:
            return CacheRefType.subclass(*args_, **kwargs_)
        else:
            return CacheRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cache(self): return self.cache
    def set_cache(self, cache): self.cache = cache
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CacheRefType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CacheRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CacheRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CacheRefType'):
        if self.cache is not None and 'cache' not in already_processed:
            already_processed.add('cache')
            outfile.write(' cache=%s' % (quote_attrib(self.cache), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CacheRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cache', node)
        if value is not None and 'cache' not in already_processed:
            already_processed.add('cache')
            self.cache = value
            self.validate_RefType(self.cache)    # validate type RefType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CacheRefType


class CacheAccessType(CacheRefType):
    subclass = None
    superclass = CacheRefType
    def __init__(self, cache=None, access=None):
        self.original_tagname_ = None
        super(CacheAccessType, self).__init__(cache, )
        self.access = _cast(None, access)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CacheAccessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CacheAccessType.subclass:
            return CacheAccessType.subclass(*args_, **kwargs_)
        else:
            return CacheAccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def validate_AccessType(self, value):
        # Validate type AccessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read', 'write']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AccessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(CacheAccessType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CacheAccessType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CacheAccessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CacheAccessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CacheAccessType'):
        super(CacheAccessType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CacheAccessType')
        if self.access is not None and 'access' not in already_processed:
            already_processed.add('access')
            outfile.write(' access=%s' % (quote_attrib(self.access), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CacheAccessType', fromsubclass_=False, pretty_print=True):
        super(CacheAccessType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('access', node)
        if value is not None and 'access' not in already_processed:
            already_processed.add('access')
            self.access = value
            self.validate_AccessType(self.access)    # validate type AccessType
        super(CacheAccessType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CacheAccessType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CacheAccessType


class FifoPowerStateType(VoltageFrequencyConditionListType):
    subclass = None
    superclass = VoltageFrequencyConditionListType
    def __init__(self, VoltageCondition=None, FrequencyCondition=None, FrequencyVoltageCondition=None, name=None, powerValue=None, powerUnit='pW'):
        self.original_tagname_ = None
        super(FifoPowerStateType, self).__init__(VoltageCondition, FrequencyCondition, FrequencyVoltageCondition, )
        self.name = _cast(None, name)
        self.powerValue = _cast(None, powerValue)
        self.powerUnit = _cast(None, powerUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FifoPowerStateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FifoPowerStateType.subclass:
            return FifoPowerStateType.subclass(*args_, **kwargs_)
        else:
            return FifoPowerStateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_powerValue(self): return self.powerValue
    def set_powerValue(self, powerValue): self.powerValue = powerValue
    def get_powerUnit(self): return self.powerUnit
    def set_powerUnit(self, powerUnit): self.powerUnit = powerUnit
    def validate_NameType(self, value):
        # Validate type NameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NameType_patterns_, ))
    validate_NameType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_PowerValueType(self, value):
        # Validate type PowerValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PowerValueType' % {"value" : value} )
    def validate_PowerUnitType(self, value):
        # Validate type PowerUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pW', 'nW', 'uW', 'mW', 'W']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PowerUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(FifoPowerStateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FifoPowerStateType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FifoPowerStateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FifoPowerStateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FifoPowerStateType'):
        super(FifoPowerStateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FifoPowerStateType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.powerValue is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            outfile.write(' powerValue=%s' % (quote_attrib(self.powerValue), ))
        if self.powerUnit != "pW" and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            outfile.write(' powerUnit=%s' % (quote_attrib(self.powerUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FifoPowerStateType', fromsubclass_=False, pretty_print=True):
        super(FifoPowerStateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NameType(self.name)    # validate type NameType
        value = find_attr_value_('powerValue', node)
        if value is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            self.powerValue = value
            self.validate_PowerValueType(self.powerValue)    # validate type PowerValueType
        value = find_attr_value_('powerUnit', node)
        if value is not None and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            self.powerUnit = value
            self.validate_PowerUnitType(self.powerUnit)    # validate type PowerUnitType
        super(FifoPowerStateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FifoPowerStateType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FifoPowerStateType


class FifoPowerModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, leakageCurrentValue='0', leakageCurrentUnit='pA', cellLeakageCurrentValue='0', cellLeakageCurrentUnit='pA', switchedCapacitanceValue='0', switchedCapacitanceUnit='pF', cellSwitchedCapacitanceValue='0', cellSwitchedCapacitanceUnit='pF', readCapacitanceValue='0', readCapacitanceUnit='pF', writeCapacitanceValue='0', writeCapacitanceUnit='pF', FifoPowerState=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.leakageCurrentValue = _cast(None, leakageCurrentValue)
        self.leakageCurrentUnit = _cast(None, leakageCurrentUnit)
        self.cellLeakageCurrentValue = _cast(None, cellLeakageCurrentValue)
        self.cellLeakageCurrentUnit = _cast(None, cellLeakageCurrentUnit)
        self.switchedCapacitanceValue = _cast(None, switchedCapacitanceValue)
        self.switchedCapacitanceUnit = _cast(None, switchedCapacitanceUnit)
        self.cellSwitchedCapacitanceValue = _cast(None, cellSwitchedCapacitanceValue)
        self.cellSwitchedCapacitanceUnit = _cast(None, cellSwitchedCapacitanceUnit)
        self.readCapacitanceValue = _cast(None, readCapacitanceValue)
        self.readCapacitanceUnit = _cast(None, readCapacitanceUnit)
        self.writeCapacitanceValue = _cast(None, writeCapacitanceValue)
        self.writeCapacitanceUnit = _cast(None, writeCapacitanceUnit)
        if FifoPowerState is None:
            self.FifoPowerState = []
        else:
            self.FifoPowerState = FifoPowerState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FifoPowerModelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FifoPowerModelType.subclass:
            return FifoPowerModelType.subclass(*args_, **kwargs_)
        else:
            return FifoPowerModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FifoPowerState(self): return self.FifoPowerState
    def set_FifoPowerState(self, FifoPowerState): self.FifoPowerState = FifoPowerState
    def add_FifoPowerState(self, value): self.FifoPowerState.append(value)
    def insert_FifoPowerState_at(self, index, value): self.FifoPowerState.insert(index, value)
    def replace_FifoPowerState_at(self, index, value): self.FifoPowerState[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_leakageCurrentValue(self): return self.leakageCurrentValue
    def set_leakageCurrentValue(self, leakageCurrentValue): self.leakageCurrentValue = leakageCurrentValue
    def get_leakageCurrentUnit(self): return self.leakageCurrentUnit
    def set_leakageCurrentUnit(self, leakageCurrentUnit): self.leakageCurrentUnit = leakageCurrentUnit
    def get_cellLeakageCurrentValue(self): return self.cellLeakageCurrentValue
    def set_cellLeakageCurrentValue(self, cellLeakageCurrentValue): self.cellLeakageCurrentValue = cellLeakageCurrentValue
    def get_cellLeakageCurrentUnit(self): return self.cellLeakageCurrentUnit
    def set_cellLeakageCurrentUnit(self, cellLeakageCurrentUnit): self.cellLeakageCurrentUnit = cellLeakageCurrentUnit
    def get_switchedCapacitanceValue(self): return self.switchedCapacitanceValue
    def set_switchedCapacitanceValue(self, switchedCapacitanceValue): self.switchedCapacitanceValue = switchedCapacitanceValue
    def get_switchedCapacitanceUnit(self): return self.switchedCapacitanceUnit
    def set_switchedCapacitanceUnit(self, switchedCapacitanceUnit): self.switchedCapacitanceUnit = switchedCapacitanceUnit
    def get_cellSwitchedCapacitanceValue(self): return self.cellSwitchedCapacitanceValue
    def set_cellSwitchedCapacitanceValue(self, cellSwitchedCapacitanceValue): self.cellSwitchedCapacitanceValue = cellSwitchedCapacitanceValue
    def get_cellSwitchedCapacitanceUnit(self): return self.cellSwitchedCapacitanceUnit
    def set_cellSwitchedCapacitanceUnit(self, cellSwitchedCapacitanceUnit): self.cellSwitchedCapacitanceUnit = cellSwitchedCapacitanceUnit
    def get_readCapacitanceValue(self): return self.readCapacitanceValue
    def set_readCapacitanceValue(self, readCapacitanceValue): self.readCapacitanceValue = readCapacitanceValue
    def get_readCapacitanceUnit(self): return self.readCapacitanceUnit
    def set_readCapacitanceUnit(self, readCapacitanceUnit): self.readCapacitanceUnit = readCapacitanceUnit
    def get_writeCapacitanceValue(self): return self.writeCapacitanceValue
    def set_writeCapacitanceValue(self, writeCapacitanceValue): self.writeCapacitanceValue = writeCapacitanceValue
    def get_writeCapacitanceUnit(self): return self.writeCapacitanceUnit
    def set_writeCapacitanceUnit(self, writeCapacitanceUnit): self.writeCapacitanceUnit = writeCapacitanceUnit
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_CurrentValueType(self, value):
        # Validate type CurrentValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CurrentValueType' % {"value" : value} )
    def validate_CurrentUnitType(self, value):
        # Validate type CurrentUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pA', 'nA', 'uA', 'mA', 'A']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CurrentUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CapacitanceValueType(self, value):
        # Validate type CapacitanceValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CapacitanceValueType' % {"value" : value} )
    def validate_CapacitanceUnitType(self, value):
        # Validate type CapacitanceUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fF', 'pF', 'nF', 'uF', 'mF', 'F']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CapacitanceUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FifoPowerState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FifoPowerModelType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FifoPowerModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FifoPowerModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FifoPowerModelType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.leakageCurrentValue != "0" and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            outfile.write(' leakageCurrentValue=%s' % (quote_attrib(self.leakageCurrentValue), ))
        if self.leakageCurrentUnit != "pA" and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            outfile.write(' leakageCurrentUnit=%s' % (quote_attrib(self.leakageCurrentUnit), ))
        if self.cellLeakageCurrentValue != "0" and 'cellLeakageCurrentValue' not in already_processed:
            already_processed.add('cellLeakageCurrentValue')
            outfile.write(' cellLeakageCurrentValue=%s' % (quote_attrib(self.cellLeakageCurrentValue), ))
        if self.cellLeakageCurrentUnit != "pA" and 'cellLeakageCurrentUnit' not in already_processed:
            already_processed.add('cellLeakageCurrentUnit')
            outfile.write(' cellLeakageCurrentUnit=%s' % (quote_attrib(self.cellLeakageCurrentUnit), ))
        if self.switchedCapacitanceValue != "0" and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            outfile.write(' switchedCapacitanceValue=%s' % (quote_attrib(self.switchedCapacitanceValue), ))
        if self.switchedCapacitanceUnit != "pF" and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            outfile.write(' switchedCapacitanceUnit=%s' % (quote_attrib(self.switchedCapacitanceUnit), ))
        if self.cellSwitchedCapacitanceValue != "0" and 'cellSwitchedCapacitanceValue' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceValue')
            outfile.write(' cellSwitchedCapacitanceValue=%s' % (quote_attrib(self.cellSwitchedCapacitanceValue), ))
        if self.cellSwitchedCapacitanceUnit != "pF" and 'cellSwitchedCapacitanceUnit' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceUnit')
            outfile.write(' cellSwitchedCapacitanceUnit=%s' % (quote_attrib(self.cellSwitchedCapacitanceUnit), ))
        if self.readCapacitanceValue != "0" and 'readCapacitanceValue' not in already_processed:
            already_processed.add('readCapacitanceValue')
            outfile.write(' readCapacitanceValue=%s' % (quote_attrib(self.readCapacitanceValue), ))
        if self.readCapacitanceUnit != "pF" and 'readCapacitanceUnit' not in already_processed:
            already_processed.add('readCapacitanceUnit')
            outfile.write(' readCapacitanceUnit=%s' % (quote_attrib(self.readCapacitanceUnit), ))
        if self.writeCapacitanceValue != "0" and 'writeCapacitanceValue' not in already_processed:
            already_processed.add('writeCapacitanceValue')
            outfile.write(' writeCapacitanceValue=%s' % (quote_attrib(self.writeCapacitanceValue), ))
        if self.writeCapacitanceUnit != "pF" and 'writeCapacitanceUnit' not in already_processed:
            already_processed.add('writeCapacitanceUnit')
            outfile.write(' writeCapacitanceUnit=%s' % (quote_attrib(self.writeCapacitanceUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FifoPowerModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FifoPowerState_ in self.FifoPowerState:
            FifoPowerState_.export(outfile, level, namespace_, name_='FifoPowerState', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('leakageCurrentValue', node)
        if value is not None and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            self.leakageCurrentValue = value
            self.validate_CurrentValueType(self.leakageCurrentValue)    # validate type CurrentValueType
        value = find_attr_value_('leakageCurrentUnit', node)
        if value is not None and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            self.leakageCurrentUnit = value
            self.validate_CurrentUnitType(self.leakageCurrentUnit)    # validate type CurrentUnitType
        value = find_attr_value_('cellLeakageCurrentValue', node)
        if value is not None and 'cellLeakageCurrentValue' not in already_processed:
            already_processed.add('cellLeakageCurrentValue')
            self.cellLeakageCurrentValue = value
            self.validate_CurrentValueType(self.cellLeakageCurrentValue)    # validate type CurrentValueType
        value = find_attr_value_('cellLeakageCurrentUnit', node)
        if value is not None and 'cellLeakageCurrentUnit' not in already_processed:
            already_processed.add('cellLeakageCurrentUnit')
            self.cellLeakageCurrentUnit = value
            self.validate_CurrentUnitType(self.cellLeakageCurrentUnit)    # validate type CurrentUnitType
        value = find_attr_value_('switchedCapacitanceValue', node)
        if value is not None and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            self.switchedCapacitanceValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceUnit', node)
        if value is not None and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            self.switchedCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('cellSwitchedCapacitanceValue', node)
        if value is not None and 'cellSwitchedCapacitanceValue' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceValue')
            self.cellSwitchedCapacitanceValue = value
            self.validate_CapacitanceValueType(self.cellSwitchedCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('cellSwitchedCapacitanceUnit', node)
        if value is not None and 'cellSwitchedCapacitanceUnit' not in already_processed:
            already_processed.add('cellSwitchedCapacitanceUnit')
            self.cellSwitchedCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.cellSwitchedCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('readCapacitanceValue', node)
        if value is not None and 'readCapacitanceValue' not in already_processed:
            already_processed.add('readCapacitanceValue')
            self.readCapacitanceValue = value
            self.validate_CapacitanceValueType(self.readCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('readCapacitanceUnit', node)
        if value is not None and 'readCapacitanceUnit' not in already_processed:
            already_processed.add('readCapacitanceUnit')
            self.readCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.readCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('writeCapacitanceValue', node)
        if value is not None and 'writeCapacitanceValue' not in already_processed:
            already_processed.add('writeCapacitanceValue')
            self.writeCapacitanceValue = value
            self.validate_CapacitanceValueType(self.writeCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('writeCapacitanceUnit', node)
        if value is not None and 'writeCapacitanceUnit' not in already_processed:
            already_processed.add('writeCapacitanceUnit')
            self.writeCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.writeCapacitanceUnit)    # validate type CapacitanceUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FifoPowerState':
            obj_ = FifoPowerStateType.factory()
            obj_.build(child_)
            self.FifoPowerState.append(obj_)
            obj_.original_tagname_ = 'FifoPowerState'
# end class FifoPowerModelType


class FifoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, entrySizeValue=None, entrySizeUnit=None, entryCount=None, readThroughputValue=None, readThroughputUnit='bit/cycle', readLatencyValue='0', readLatencyUnit='cycles', writeThroughputValue=None, writeThroughputUnit='bit/cycle', writeLatencyValue='0', writeLatencyUnit='cycles', frequencyDomain=None, voltageDomain=None, fifoPowerModel=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.entrySizeValue = _cast(None, entrySizeValue)
        self.entrySizeUnit = _cast(None, entrySizeUnit)
        self.entryCount = _cast(None, entryCount)
        self.readThroughputValue = _cast(None, readThroughputValue)
        self.readThroughputUnit = _cast(None, readThroughputUnit)
        self.readLatencyValue = _cast(None, readLatencyValue)
        self.readLatencyUnit = _cast(None, readLatencyUnit)
        self.writeThroughputValue = _cast(None, writeThroughputValue)
        self.writeThroughputUnit = _cast(None, writeThroughputUnit)
        self.writeLatencyValue = _cast(None, writeLatencyValue)
        self.writeLatencyUnit = _cast(None, writeLatencyUnit)
        self.frequencyDomain = _cast(None, frequencyDomain)
        self.voltageDomain = _cast(None, voltageDomain)
        self.fifoPowerModel = _cast(None, fifoPowerModel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FifoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FifoType.subclass:
            return FifoType.subclass(*args_, **kwargs_)
        else:
            return FifoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_entrySizeValue(self): return self.entrySizeValue
    def set_entrySizeValue(self, entrySizeValue): self.entrySizeValue = entrySizeValue
    def get_entrySizeUnit(self): return self.entrySizeUnit
    def set_entrySizeUnit(self, entrySizeUnit): self.entrySizeUnit = entrySizeUnit
    def get_entryCount(self): return self.entryCount
    def set_entryCount(self, entryCount): self.entryCount = entryCount
    def get_readThroughputValue(self): return self.readThroughputValue
    def set_readThroughputValue(self, readThroughputValue): self.readThroughputValue = readThroughputValue
    def get_readThroughputUnit(self): return self.readThroughputUnit
    def set_readThroughputUnit(self, readThroughputUnit): self.readThroughputUnit = readThroughputUnit
    def get_readLatencyValue(self): return self.readLatencyValue
    def set_readLatencyValue(self, readLatencyValue): self.readLatencyValue = readLatencyValue
    def get_readLatencyUnit(self): return self.readLatencyUnit
    def set_readLatencyUnit(self, readLatencyUnit): self.readLatencyUnit = readLatencyUnit
    def get_writeThroughputValue(self): return self.writeThroughputValue
    def set_writeThroughputValue(self, writeThroughputValue): self.writeThroughputValue = writeThroughputValue
    def get_writeThroughputUnit(self): return self.writeThroughputUnit
    def set_writeThroughputUnit(self, writeThroughputUnit): self.writeThroughputUnit = writeThroughputUnit
    def get_writeLatencyValue(self): return self.writeLatencyValue
    def set_writeLatencyValue(self, writeLatencyValue): self.writeLatencyValue = writeLatencyValue
    def get_writeLatencyUnit(self): return self.writeLatencyUnit
    def set_writeLatencyUnit(self, writeLatencyUnit): self.writeLatencyUnit = writeLatencyUnit
    def get_frequencyDomain(self): return self.frequencyDomain
    def set_frequencyDomain(self, frequencyDomain): self.frequencyDomain = frequencyDomain
    def get_voltageDomain(self): return self.voltageDomain
    def set_voltageDomain(self, voltageDomain): self.voltageDomain = voltageDomain
    def get_fifoPowerModel(self): return self.fifoPowerModel
    def set_fifoPowerModel(self, fifoPowerModel): self.fifoPowerModel = fifoPowerModel
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_SizeValueType(self, value):
        # Validate type SizeValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on SizeValueType' % {"value" : value} )
    def validate_SizeUnitType(self, value):
        # Validate type SizeUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bit', 'B', 'kB', 'KiB', 'MB', 'MiB', 'GB', 'GiB', 'TB', 'TiB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SizeUnitType' % {"value" : value.encode("utf-8")} )
    def validate_PositiveIntType(self, value):
        # Validate type PositiveIntType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ThroughputValueType(self, value):
        # Validate type ThroughputValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on ThroughputValueType' % {"value" : value} )
    def validate_ThroughputUnitType(self, value):
        # Validate type ThroughputUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bit/cycle', 'B/cycle', 'kB/cycle', 'KiB/cycle']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ThroughputUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CyclesValueType(self, value):
        # Validate type CyclesValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CyclesValueType' % {"value" : value} )
    def validate_CyclesUnitType(self, value):
        # Validate type CyclesUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cycles', 'kcycles', 'Mcycles']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CyclesUnitType' % {"value" : value.encode("utf-8")} )
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FifoType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FifoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FifoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FifoType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.entrySizeValue is not None and 'entrySizeValue' not in already_processed:
            already_processed.add('entrySizeValue')
            outfile.write(' entrySizeValue=%s' % (quote_attrib(self.entrySizeValue), ))
        if self.entrySizeUnit is not None and 'entrySizeUnit' not in already_processed:
            already_processed.add('entrySizeUnit')
            outfile.write(' entrySizeUnit=%s' % (quote_attrib(self.entrySizeUnit), ))
        if self.entryCount is not None and 'entryCount' not in already_processed:
            already_processed.add('entryCount')
            outfile.write(' entryCount=%s' % (quote_attrib(self.entryCount), ))
        if self.readThroughputValue is not None and 'readThroughputValue' not in already_processed:
            already_processed.add('readThroughputValue')
            outfile.write(' readThroughputValue=%s' % (quote_attrib(self.readThroughputValue), ))
        if self.readThroughputUnit != "bit/cycle" and 'readThroughputUnit' not in already_processed:
            already_processed.add('readThroughputUnit')
            outfile.write(' readThroughputUnit=%s' % (quote_attrib(self.readThroughputUnit), ))
        if self.readLatencyValue != "0" and 'readLatencyValue' not in already_processed:
            already_processed.add('readLatencyValue')
            outfile.write(' readLatencyValue=%s' % (quote_attrib(self.readLatencyValue), ))
        if self.readLatencyUnit != "cycles" and 'readLatencyUnit' not in already_processed:
            already_processed.add('readLatencyUnit')
            outfile.write(' readLatencyUnit=%s' % (quote_attrib(self.readLatencyUnit), ))
        if self.writeThroughputValue is not None and 'writeThroughputValue' not in already_processed:
            already_processed.add('writeThroughputValue')
            outfile.write(' writeThroughputValue=%s' % (quote_attrib(self.writeThroughputValue), ))
        if self.writeThroughputUnit != "bit/cycle" and 'writeThroughputUnit' not in already_processed:
            already_processed.add('writeThroughputUnit')
            outfile.write(' writeThroughputUnit=%s' % (quote_attrib(self.writeThroughputUnit), ))
        if self.writeLatencyValue != "0" and 'writeLatencyValue' not in already_processed:
            already_processed.add('writeLatencyValue')
            outfile.write(' writeLatencyValue=%s' % (quote_attrib(self.writeLatencyValue), ))
        if self.writeLatencyUnit != "cycles" and 'writeLatencyUnit' not in already_processed:
            already_processed.add('writeLatencyUnit')
            outfile.write(' writeLatencyUnit=%s' % (quote_attrib(self.writeLatencyUnit), ))
        if self.frequencyDomain is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            outfile.write(' frequencyDomain=%s' % (quote_attrib(self.frequencyDomain), ))
        if self.voltageDomain is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            outfile.write(' voltageDomain=%s' % (quote_attrib(self.voltageDomain), ))
        if self.fifoPowerModel is not None and 'fifoPowerModel' not in already_processed:
            already_processed.add('fifoPowerModel')
            outfile.write(' fifoPowerModel=%s' % (quote_attrib(self.fifoPowerModel), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FifoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('entrySizeValue', node)
        if value is not None and 'entrySizeValue' not in already_processed:
            already_processed.add('entrySizeValue')
            self.entrySizeValue = value
            self.validate_SizeValueType(self.entrySizeValue)    # validate type SizeValueType
        value = find_attr_value_('entrySizeUnit', node)
        if value is not None and 'entrySizeUnit' not in already_processed:
            already_processed.add('entrySizeUnit')
            self.entrySizeUnit = value
            self.validate_SizeUnitType(self.entrySizeUnit)    # validate type SizeUnitType
        value = find_attr_value_('entryCount', node)
        if value is not None and 'entryCount' not in already_processed:
            already_processed.add('entryCount')
            try:
                self.entryCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.entryCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveIntType(self.entryCount)    # validate type PositiveIntType
        value = find_attr_value_('readThroughputValue', node)
        if value is not None and 'readThroughputValue' not in already_processed:
            already_processed.add('readThroughputValue')
            self.readThroughputValue = value
            self.validate_ThroughputValueType(self.readThroughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('readThroughputUnit', node)
        if value is not None and 'readThroughputUnit' not in already_processed:
            already_processed.add('readThroughputUnit')
            self.readThroughputUnit = value
            self.validate_ThroughputUnitType(self.readThroughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('readLatencyValue', node)
        if value is not None and 'readLatencyValue' not in already_processed:
            already_processed.add('readLatencyValue')
            self.readLatencyValue = value
            self.validate_CyclesValueType(self.readLatencyValue)    # validate type CyclesValueType
        value = find_attr_value_('readLatencyUnit', node)
        if value is not None and 'readLatencyUnit' not in already_processed:
            already_processed.add('readLatencyUnit')
            self.readLatencyUnit = value
            self.validate_CyclesUnitType(self.readLatencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('writeThroughputValue', node)
        if value is not None and 'writeThroughputValue' not in already_processed:
            already_processed.add('writeThroughputValue')
            self.writeThroughputValue = value
            self.validate_ThroughputValueType(self.writeThroughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('writeThroughputUnit', node)
        if value is not None and 'writeThroughputUnit' not in already_processed:
            already_processed.add('writeThroughputUnit')
            self.writeThroughputUnit = value
            self.validate_ThroughputUnitType(self.writeThroughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('writeLatencyValue', node)
        if value is not None and 'writeLatencyValue' not in already_processed:
            already_processed.add('writeLatencyValue')
            self.writeLatencyValue = value
            self.validate_CyclesValueType(self.writeLatencyValue)    # validate type CyclesValueType
        value = find_attr_value_('writeLatencyUnit', node)
        if value is not None and 'writeLatencyUnit' not in already_processed:
            already_processed.add('writeLatencyUnit')
            self.writeLatencyUnit = value
            self.validate_CyclesUnitType(self.writeLatencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('frequencyDomain', node)
        if value is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            self.frequencyDomain = value
            self.validate_RefType(self.frequencyDomain)    # validate type RefType
        value = find_attr_value_('voltageDomain', node)
        if value is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            self.voltageDomain = value
            self.validate_RefType(self.voltageDomain)    # validate type RefType
        value = find_attr_value_('fifoPowerModel', node)
        if value is not None and 'fifoPowerModel' not in already_processed:
            already_processed.add('fifoPowerModel')
            self.fifoPowerModel = value
            self.validate_RefType(self.fifoPowerModel)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FifoType


class FifoRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fifo=None, extensiontype_=None):
        self.original_tagname_ = None
        self.fifo = _cast(None, fifo)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FifoRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FifoRefType.subclass:
            return FifoRefType.subclass(*args_, **kwargs_)
        else:
            return FifoRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fifo(self): return self.fifo
    def set_fifo(self, fifo): self.fifo = fifo
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FifoRefType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FifoRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FifoRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FifoRefType'):
        if self.fifo is not None and 'fifo' not in already_processed:
            already_processed.add('fifo')
            outfile.write(' fifo=%s' % (quote_attrib(self.fifo), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FifoRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fifo', node)
        if value is not None and 'fifo' not in already_processed:
            already_processed.add('fifo')
            self.fifo = value
            self.validate_RefType(self.fifo)    # validate type RefType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FifoRefType


class FifoAccessType(FifoRefType):
    subclass = None
    superclass = FifoRefType
    def __init__(self, fifo=None, access=None):
        self.original_tagname_ = None
        super(FifoAccessType, self).__init__(fifo, )
        self.access = _cast(None, access)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FifoAccessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FifoAccessType.subclass:
            return FifoAccessType.subclass(*args_, **kwargs_)
        else:
            return FifoAccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def validate_AccessType(self, value):
        # Validate type AccessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read', 'write']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AccessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(FifoAccessType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FifoAccessType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FifoAccessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FifoAccessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FifoAccessType'):
        super(FifoAccessType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FifoAccessType')
        if self.access is not None and 'access' not in already_processed:
            already_processed.add('access')
            outfile.write(' access=%s' % (quote_attrib(self.access), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FifoAccessType', fromsubclass_=False, pretty_print=True):
        super(FifoAccessType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('access', node)
        if value is not None and 'access' not in already_processed:
            already_processed.add('access')
            self.access = value
            self.validate_AccessType(self.access)    # validate type AccessType
        super(FifoAccessType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FifoAccessType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FifoAccessType


class PhysicalLinkPowerStateType(VoltageFrequencyConditionListType):
    subclass = None
    superclass = VoltageFrequencyConditionListType
    def __init__(self, VoltageCondition=None, FrequencyCondition=None, FrequencyVoltageCondition=None, name=None, powerValue=None, powerUnit='pW'):
        self.original_tagname_ = None
        super(PhysicalLinkPowerStateType, self).__init__(VoltageCondition, FrequencyCondition, FrequencyVoltageCondition, )
        self.name = _cast(None, name)
        self.powerValue = _cast(None, powerValue)
        self.powerUnit = _cast(None, powerUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalLinkPowerStateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalLinkPowerStateType.subclass:
            return PhysicalLinkPowerStateType.subclass(*args_, **kwargs_)
        else:
            return PhysicalLinkPowerStateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_powerValue(self): return self.powerValue
    def set_powerValue(self, powerValue): self.powerValue = powerValue
    def get_powerUnit(self): return self.powerUnit
    def set_powerUnit(self, powerUnit): self.powerUnit = powerUnit
    def validate_NameType(self, value):
        # Validate type NameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NameType_patterns_, ))
    validate_NameType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_PowerValueType(self, value):
        # Validate type PowerValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PowerValueType' % {"value" : value} )
    def validate_PowerUnitType(self, value):
        # Validate type PowerUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pW', 'nW', 'uW', 'mW', 'W']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PowerUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(PhysicalLinkPowerStateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='PhysicalLinkPowerStateType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalLinkPowerStateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='PhysicalLinkPowerStateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='PhysicalLinkPowerStateType'):
        super(PhysicalLinkPowerStateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalLinkPowerStateType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.powerValue is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            outfile.write(' powerValue=%s' % (quote_attrib(self.powerValue), ))
        if self.powerUnit != "pW" and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            outfile.write(' powerUnit=%s' % (quote_attrib(self.powerUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='PhysicalLinkPowerStateType', fromsubclass_=False, pretty_print=True):
        super(PhysicalLinkPowerStateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NameType(self.name)    # validate type NameType
        value = find_attr_value_('powerValue', node)
        if value is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            self.powerValue = value
            self.validate_PowerValueType(self.powerValue)    # validate type PowerValueType
        value = find_attr_value_('powerUnit', node)
        if value is not None and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            self.powerUnit = value
            self.validate_PowerUnitType(self.powerUnit)    # validate type PowerUnitType
        super(PhysicalLinkPowerStateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PhysicalLinkPowerStateType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PhysicalLinkPowerStateType


class PhysicalLinkPowerModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, leakageCurrentValue='0', leakageCurrentUnit='pA', switchedCapacitanceValue='0', switchedCapacitanceUnit='pF', transferCapacitanceValue='0', transferCapacitanceUnit='pF', PhysicalLinkPowerState=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.leakageCurrentValue = _cast(None, leakageCurrentValue)
        self.leakageCurrentUnit = _cast(None, leakageCurrentUnit)
        self.switchedCapacitanceValue = _cast(None, switchedCapacitanceValue)
        self.switchedCapacitanceUnit = _cast(None, switchedCapacitanceUnit)
        self.transferCapacitanceValue = _cast(None, transferCapacitanceValue)
        self.transferCapacitanceUnit = _cast(None, transferCapacitanceUnit)
        if PhysicalLinkPowerState is None:
            self.PhysicalLinkPowerState = []
        else:
            self.PhysicalLinkPowerState = PhysicalLinkPowerState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalLinkPowerModelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalLinkPowerModelType.subclass:
            return PhysicalLinkPowerModelType.subclass(*args_, **kwargs_)
        else:
            return PhysicalLinkPowerModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PhysicalLinkPowerState(self): return self.PhysicalLinkPowerState
    def set_PhysicalLinkPowerState(self, PhysicalLinkPowerState): self.PhysicalLinkPowerState = PhysicalLinkPowerState
    def add_PhysicalLinkPowerState(self, value): self.PhysicalLinkPowerState.append(value)
    def insert_PhysicalLinkPowerState_at(self, index, value): self.PhysicalLinkPowerState.insert(index, value)
    def replace_PhysicalLinkPowerState_at(self, index, value): self.PhysicalLinkPowerState[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_leakageCurrentValue(self): return self.leakageCurrentValue
    def set_leakageCurrentValue(self, leakageCurrentValue): self.leakageCurrentValue = leakageCurrentValue
    def get_leakageCurrentUnit(self): return self.leakageCurrentUnit
    def set_leakageCurrentUnit(self, leakageCurrentUnit): self.leakageCurrentUnit = leakageCurrentUnit
    def get_switchedCapacitanceValue(self): return self.switchedCapacitanceValue
    def set_switchedCapacitanceValue(self, switchedCapacitanceValue): self.switchedCapacitanceValue = switchedCapacitanceValue
    def get_switchedCapacitanceUnit(self): return self.switchedCapacitanceUnit
    def set_switchedCapacitanceUnit(self, switchedCapacitanceUnit): self.switchedCapacitanceUnit = switchedCapacitanceUnit
    def get_transferCapacitanceValue(self): return self.transferCapacitanceValue
    def set_transferCapacitanceValue(self, transferCapacitanceValue): self.transferCapacitanceValue = transferCapacitanceValue
    def get_transferCapacitanceUnit(self): return self.transferCapacitanceUnit
    def set_transferCapacitanceUnit(self, transferCapacitanceUnit): self.transferCapacitanceUnit = transferCapacitanceUnit
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_CurrentValueType(self, value):
        # Validate type CurrentValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CurrentValueType' % {"value" : value} )
    def validate_CurrentUnitType(self, value):
        # Validate type CurrentUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pA', 'nA', 'uA', 'mA', 'A']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CurrentUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CapacitanceValueType(self, value):
        # Validate type CapacitanceValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CapacitanceValueType' % {"value" : value} )
    def validate_CapacitanceUnitType(self, value):
        # Validate type CapacitanceUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fF', 'pF', 'nF', 'uF', 'mF', 'F']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CapacitanceUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PhysicalLinkPowerState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='PhysicalLinkPowerModelType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalLinkPowerModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='PhysicalLinkPowerModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='PhysicalLinkPowerModelType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.leakageCurrentValue != "0" and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            outfile.write(' leakageCurrentValue=%s' % (quote_attrib(self.leakageCurrentValue), ))
        if self.leakageCurrentUnit != "pA" and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            outfile.write(' leakageCurrentUnit=%s' % (quote_attrib(self.leakageCurrentUnit), ))
        if self.switchedCapacitanceValue != "0" and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            outfile.write(' switchedCapacitanceValue=%s' % (quote_attrib(self.switchedCapacitanceValue), ))
        if self.switchedCapacitanceUnit != "pF" and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            outfile.write(' switchedCapacitanceUnit=%s' % (quote_attrib(self.switchedCapacitanceUnit), ))
        if self.transferCapacitanceValue != "0" and 'transferCapacitanceValue' not in already_processed:
            already_processed.add('transferCapacitanceValue')
            outfile.write(' transferCapacitanceValue=%s' % (quote_attrib(self.transferCapacitanceValue), ))
        if self.transferCapacitanceUnit != "pF" and 'transferCapacitanceUnit' not in already_processed:
            already_processed.add('transferCapacitanceUnit')
            outfile.write(' transferCapacitanceUnit=%s' % (quote_attrib(self.transferCapacitanceUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='PhysicalLinkPowerModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PhysicalLinkPowerState_ in self.PhysicalLinkPowerState:
            PhysicalLinkPowerState_.export(outfile, level, namespace_, name_='PhysicalLinkPowerState', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('leakageCurrentValue', node)
        if value is not None and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            self.leakageCurrentValue = value
            self.validate_CurrentValueType(self.leakageCurrentValue)    # validate type CurrentValueType
        value = find_attr_value_('leakageCurrentUnit', node)
        if value is not None and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            self.leakageCurrentUnit = value
            self.validate_CurrentUnitType(self.leakageCurrentUnit)    # validate type CurrentUnitType
        value = find_attr_value_('switchedCapacitanceValue', node)
        if value is not None and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            self.switchedCapacitanceValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceUnit', node)
        if value is not None and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            self.switchedCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('transferCapacitanceValue', node)
        if value is not None and 'transferCapacitanceValue' not in already_processed:
            already_processed.add('transferCapacitanceValue')
            self.transferCapacitanceValue = value
            self.validate_CapacitanceValueType(self.transferCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('transferCapacitanceUnit', node)
        if value is not None and 'transferCapacitanceUnit' not in already_processed:
            already_processed.add('transferCapacitanceUnit')
            self.transferCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.transferCapacitanceUnit)    # validate type CapacitanceUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PhysicalLinkPowerState':
            obj_ = PhysicalLinkPowerStateType.factory()
            obj_.build(child_)
            self.PhysicalLinkPowerState.append(obj_)
            obj_.original_tagname_ = 'PhysicalLinkPowerState'
# end class PhysicalLinkPowerModelType


class PhysicalLinkType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, throughputValue=None, throughputUnit='bit/cycle', latencyValue='0', latencyUnit='cycles', frequencyDomain=None, voltageDomain=None, physicalLinkPowerModel=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.throughputValue = _cast(None, throughputValue)
        self.throughputUnit = _cast(None, throughputUnit)
        self.latencyValue = _cast(None, latencyValue)
        self.latencyUnit = _cast(None, latencyUnit)
        self.frequencyDomain = _cast(None, frequencyDomain)
        self.voltageDomain = _cast(None, voltageDomain)
        self.physicalLinkPowerModel = _cast(None, physicalLinkPowerModel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalLinkType.subclass:
            return PhysicalLinkType.subclass(*args_, **kwargs_)
        else:
            return PhysicalLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_throughputValue(self): return self.throughputValue
    def set_throughputValue(self, throughputValue): self.throughputValue = throughputValue
    def get_throughputUnit(self): return self.throughputUnit
    def set_throughputUnit(self, throughputUnit): self.throughputUnit = throughputUnit
    def get_latencyValue(self): return self.latencyValue
    def set_latencyValue(self, latencyValue): self.latencyValue = latencyValue
    def get_latencyUnit(self): return self.latencyUnit
    def set_latencyUnit(self, latencyUnit): self.latencyUnit = latencyUnit
    def get_frequencyDomain(self): return self.frequencyDomain
    def set_frequencyDomain(self, frequencyDomain): self.frequencyDomain = frequencyDomain
    def get_voltageDomain(self): return self.voltageDomain
    def set_voltageDomain(self, voltageDomain): self.voltageDomain = voltageDomain
    def get_physicalLinkPowerModel(self): return self.physicalLinkPowerModel
    def set_physicalLinkPowerModel(self, physicalLinkPowerModel): self.physicalLinkPowerModel = physicalLinkPowerModel
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_ThroughputValueType(self, value):
        # Validate type ThroughputValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on ThroughputValueType' % {"value" : value} )
    def validate_ThroughputUnitType(self, value):
        # Validate type ThroughputUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bit/cycle', 'B/cycle', 'kB/cycle', 'KiB/cycle']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ThroughputUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CyclesValueType(self, value):
        # Validate type CyclesValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CyclesValueType' % {"value" : value} )
    def validate_CyclesUnitType(self, value):
        # Validate type CyclesUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cycles', 'kcycles', 'Mcycles']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CyclesUnitType' % {"value" : value.encode("utf-8")} )
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='PhysicalLinkType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='PhysicalLinkType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='PhysicalLinkType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.throughputValue is not None and 'throughputValue' not in already_processed:
            already_processed.add('throughputValue')
            outfile.write(' throughputValue=%s' % (quote_attrib(self.throughputValue), ))
        if self.throughputUnit != "bit/cycle" and 'throughputUnit' not in already_processed:
            already_processed.add('throughputUnit')
            outfile.write(' throughputUnit=%s' % (quote_attrib(self.throughputUnit), ))
        if self.latencyValue != "0" and 'latencyValue' not in already_processed:
            already_processed.add('latencyValue')
            outfile.write(' latencyValue=%s' % (quote_attrib(self.latencyValue), ))
        if self.latencyUnit != "cycles" and 'latencyUnit' not in already_processed:
            already_processed.add('latencyUnit')
            outfile.write(' latencyUnit=%s' % (quote_attrib(self.latencyUnit), ))
        if self.frequencyDomain is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            outfile.write(' frequencyDomain=%s' % (quote_attrib(self.frequencyDomain), ))
        if self.voltageDomain is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            outfile.write(' voltageDomain=%s' % (quote_attrib(self.voltageDomain), ))
        if self.physicalLinkPowerModel is not None and 'physicalLinkPowerModel' not in already_processed:
            already_processed.add('physicalLinkPowerModel')
            outfile.write(' physicalLinkPowerModel=%s' % (quote_attrib(self.physicalLinkPowerModel), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='PhysicalLinkType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('throughputValue', node)
        if value is not None and 'throughputValue' not in already_processed:
            already_processed.add('throughputValue')
            self.throughputValue = value
            self.validate_ThroughputValueType(self.throughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('throughputUnit', node)
        if value is not None and 'throughputUnit' not in already_processed:
            already_processed.add('throughputUnit')
            self.throughputUnit = value
            self.validate_ThroughputUnitType(self.throughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('latencyValue', node)
        if value is not None and 'latencyValue' not in already_processed:
            already_processed.add('latencyValue')
            self.latencyValue = value
            self.validate_CyclesValueType(self.latencyValue)    # validate type CyclesValueType
        value = find_attr_value_('latencyUnit', node)
        if value is not None and 'latencyUnit' not in already_processed:
            already_processed.add('latencyUnit')
            self.latencyUnit = value
            self.validate_CyclesUnitType(self.latencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('frequencyDomain', node)
        if value is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            self.frequencyDomain = value
            self.validate_RefType(self.frequencyDomain)    # validate type RefType
        value = find_attr_value_('voltageDomain', node)
        if value is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            self.voltageDomain = value
            self.validate_RefType(self.voltageDomain)    # validate type RefType
        value = find_attr_value_('physicalLinkPowerModel', node)
        if value is not None and 'physicalLinkPowerModel' not in already_processed:
            already_processed.add('physicalLinkPowerModel')
            self.physicalLinkPowerModel = value
            self.validate_RefType(self.physicalLinkPowerModel)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhysicalLinkType


class PhysicalLinkRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, physicalLink=None):
        self.original_tagname_ = None
        self.physicalLink = _cast(None, physicalLink)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalLinkRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalLinkRefType.subclass:
            return PhysicalLinkRefType.subclass(*args_, **kwargs_)
        else:
            return PhysicalLinkRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_physicalLink(self): return self.physicalLink
    def set_physicalLink(self, physicalLink): self.physicalLink = physicalLink
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='PhysicalLinkRefType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalLinkRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='PhysicalLinkRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='PhysicalLinkRefType'):
        if self.physicalLink is not None and 'physicalLink' not in already_processed:
            already_processed.add('physicalLink')
            outfile.write(' physicalLink=%s' % (quote_attrib(self.physicalLink), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='PhysicalLinkRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('physicalLink', node)
        if value is not None and 'physicalLink' not in already_processed:
            already_processed.add('physicalLink')
            self.physicalLink = value
            self.validate_RefType(self.physicalLink)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhysicalLinkRefType


class DMAControllerPowerStateType(VoltageFrequencyConditionListType):
    subclass = None
    superclass = VoltageFrequencyConditionListType
    def __init__(self, VoltageCondition=None, FrequencyCondition=None, FrequencyVoltageCondition=None, name=None, powerValue=None, powerUnit='pW'):
        self.original_tagname_ = None
        super(DMAControllerPowerStateType, self).__init__(VoltageCondition, FrequencyCondition, FrequencyVoltageCondition, )
        self.name = _cast(None, name)
        self.powerValue = _cast(None, powerValue)
        self.powerUnit = _cast(None, powerUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DMAControllerPowerStateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DMAControllerPowerStateType.subclass:
            return DMAControllerPowerStateType.subclass(*args_, **kwargs_)
        else:
            return DMAControllerPowerStateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_powerValue(self): return self.powerValue
    def set_powerValue(self, powerValue): self.powerValue = powerValue
    def get_powerUnit(self): return self.powerUnit
    def set_powerUnit(self, powerUnit): self.powerUnit = powerUnit
    def validate_NameType(self, value):
        # Validate type NameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NameType_patterns_, ))
    validate_NameType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_PowerValueType(self, value):
        # Validate type PowerValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on PowerValueType' % {"value" : value} )
    def validate_PowerUnitType(self, value):
        # Validate type PowerUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pW', 'nW', 'uW', 'mW', 'W']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PowerUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(DMAControllerPowerStateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='DMAControllerPowerStateType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DMAControllerPowerStateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='DMAControllerPowerStateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='DMAControllerPowerStateType'):
        super(DMAControllerPowerStateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DMAControllerPowerStateType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.powerValue is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            outfile.write(' powerValue=%s' % (quote_attrib(self.powerValue), ))
        if self.powerUnit != "pW" and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            outfile.write(' powerUnit=%s' % (quote_attrib(self.powerUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='DMAControllerPowerStateType', fromsubclass_=False, pretty_print=True):
        super(DMAControllerPowerStateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_NameType(self.name)    # validate type NameType
        value = find_attr_value_('powerValue', node)
        if value is not None and 'powerValue' not in already_processed:
            already_processed.add('powerValue')
            self.powerValue = value
            self.validate_PowerValueType(self.powerValue)    # validate type PowerValueType
        value = find_attr_value_('powerUnit', node)
        if value is not None and 'powerUnit' not in already_processed:
            already_processed.add('powerUnit')
            self.powerUnit = value
            self.validate_PowerUnitType(self.powerUnit)    # validate type PowerUnitType
        super(DMAControllerPowerStateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DMAControllerPowerStateType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DMAControllerPowerStateType


class DMAControllerPowerModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, leakageCurrentValue='0', leakageCurrentUnit='pA', switchedCapacitanceValue='0', switchedCapacitanceUnit='pF', transferCapacitanceValue='0', transferCapacitanceUnit='pF', DMAControllerPowerState=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.leakageCurrentValue = _cast(None, leakageCurrentValue)
        self.leakageCurrentUnit = _cast(None, leakageCurrentUnit)
        self.switchedCapacitanceValue = _cast(None, switchedCapacitanceValue)
        self.switchedCapacitanceUnit = _cast(None, switchedCapacitanceUnit)
        self.transferCapacitanceValue = _cast(None, transferCapacitanceValue)
        self.transferCapacitanceUnit = _cast(None, transferCapacitanceUnit)
        if DMAControllerPowerState is None:
            self.DMAControllerPowerState = []
        else:
            self.DMAControllerPowerState = DMAControllerPowerState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DMAControllerPowerModelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DMAControllerPowerModelType.subclass:
            return DMAControllerPowerModelType.subclass(*args_, **kwargs_)
        else:
            return DMAControllerPowerModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DMAControllerPowerState(self): return self.DMAControllerPowerState
    def set_DMAControllerPowerState(self, DMAControllerPowerState): self.DMAControllerPowerState = DMAControllerPowerState
    def add_DMAControllerPowerState(self, value): self.DMAControllerPowerState.append(value)
    def insert_DMAControllerPowerState_at(self, index, value): self.DMAControllerPowerState.insert(index, value)
    def replace_DMAControllerPowerState_at(self, index, value): self.DMAControllerPowerState[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_leakageCurrentValue(self): return self.leakageCurrentValue
    def set_leakageCurrentValue(self, leakageCurrentValue): self.leakageCurrentValue = leakageCurrentValue
    def get_leakageCurrentUnit(self): return self.leakageCurrentUnit
    def set_leakageCurrentUnit(self, leakageCurrentUnit): self.leakageCurrentUnit = leakageCurrentUnit
    def get_switchedCapacitanceValue(self): return self.switchedCapacitanceValue
    def set_switchedCapacitanceValue(self, switchedCapacitanceValue): self.switchedCapacitanceValue = switchedCapacitanceValue
    def get_switchedCapacitanceUnit(self): return self.switchedCapacitanceUnit
    def set_switchedCapacitanceUnit(self, switchedCapacitanceUnit): self.switchedCapacitanceUnit = switchedCapacitanceUnit
    def get_transferCapacitanceValue(self): return self.transferCapacitanceValue
    def set_transferCapacitanceValue(self, transferCapacitanceValue): self.transferCapacitanceValue = transferCapacitanceValue
    def get_transferCapacitanceUnit(self): return self.transferCapacitanceUnit
    def set_transferCapacitanceUnit(self, transferCapacitanceUnit): self.transferCapacitanceUnit = transferCapacitanceUnit
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_CurrentValueType(self, value):
        # Validate type CurrentValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CurrentValueType' % {"value" : value} )
    def validate_CurrentUnitType(self, value):
        # Validate type CurrentUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pA', 'nA', 'uA', 'mA', 'A']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CurrentUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CapacitanceValueType(self, value):
        # Validate type CapacitanceValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CapacitanceValueType' % {"value" : value} )
    def validate_CapacitanceUnitType(self, value):
        # Validate type CapacitanceUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fF', 'pF', 'nF', 'uF', 'mF', 'F']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CapacitanceUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DMAControllerPowerState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='DMAControllerPowerModelType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DMAControllerPowerModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='DMAControllerPowerModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='DMAControllerPowerModelType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.leakageCurrentValue != "0" and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            outfile.write(' leakageCurrentValue=%s' % (quote_attrib(self.leakageCurrentValue), ))
        if self.leakageCurrentUnit != "pA" and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            outfile.write(' leakageCurrentUnit=%s' % (quote_attrib(self.leakageCurrentUnit), ))
        if self.switchedCapacitanceValue != "0" and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            outfile.write(' switchedCapacitanceValue=%s' % (quote_attrib(self.switchedCapacitanceValue), ))
        if self.switchedCapacitanceUnit != "pF" and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            outfile.write(' switchedCapacitanceUnit=%s' % (quote_attrib(self.switchedCapacitanceUnit), ))
        if self.transferCapacitanceValue != "0" and 'transferCapacitanceValue' not in already_processed:
            already_processed.add('transferCapacitanceValue')
            outfile.write(' transferCapacitanceValue=%s' % (quote_attrib(self.transferCapacitanceValue), ))
        if self.transferCapacitanceUnit != "pF" and 'transferCapacitanceUnit' not in already_processed:
            already_processed.add('transferCapacitanceUnit')
            outfile.write(' transferCapacitanceUnit=%s' % (quote_attrib(self.transferCapacitanceUnit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='DMAControllerPowerModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DMAControllerPowerState_ in self.DMAControllerPowerState:
            DMAControllerPowerState_.export(outfile, level, namespace_, name_='DMAControllerPowerState', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('leakageCurrentValue', node)
        if value is not None and 'leakageCurrentValue' not in already_processed:
            already_processed.add('leakageCurrentValue')
            self.leakageCurrentValue = value
            self.validate_CurrentValueType(self.leakageCurrentValue)    # validate type CurrentValueType
        value = find_attr_value_('leakageCurrentUnit', node)
        if value is not None and 'leakageCurrentUnit' not in already_processed:
            already_processed.add('leakageCurrentUnit')
            self.leakageCurrentUnit = value
            self.validate_CurrentUnitType(self.leakageCurrentUnit)    # validate type CurrentUnitType
        value = find_attr_value_('switchedCapacitanceValue', node)
        if value is not None and 'switchedCapacitanceValue' not in already_processed:
            already_processed.add('switchedCapacitanceValue')
            self.switchedCapacitanceValue = value
            self.validate_CapacitanceValueType(self.switchedCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('switchedCapacitanceUnit', node)
        if value is not None and 'switchedCapacitanceUnit' not in already_processed:
            already_processed.add('switchedCapacitanceUnit')
            self.switchedCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.switchedCapacitanceUnit)    # validate type CapacitanceUnitType
        value = find_attr_value_('transferCapacitanceValue', node)
        if value is not None and 'transferCapacitanceValue' not in already_processed:
            already_processed.add('transferCapacitanceValue')
            self.transferCapacitanceValue = value
            self.validate_CapacitanceValueType(self.transferCapacitanceValue)    # validate type CapacitanceValueType
        value = find_attr_value_('transferCapacitanceUnit', node)
        if value is not None and 'transferCapacitanceUnit' not in already_processed:
            already_processed.add('transferCapacitanceUnit')
            self.transferCapacitanceUnit = value
            self.validate_CapacitanceUnitType(self.transferCapacitanceUnit)    # validate type CapacitanceUnitType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DMAControllerPowerState':
            obj_ = DMAControllerPowerStateType.factory()
            obj_.build(child_)
            self.DMAControllerPowerState.append(obj_)
            obj_.original_tagname_ = 'DMAControllerPowerState'
# end class DMAControllerPowerModelType


class DMAControllerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, channelCount=None, throughputValue=None, throughputUnit='bit/cycle', latencyValue='0', latencyUnit='cycles', frequencyDomain=None, voltageDomain=None, dmaControllerPowerModel=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.channelCount = _cast(None, channelCount)
        self.throughputValue = _cast(None, throughputValue)
        self.throughputUnit = _cast(None, throughputUnit)
        self.latencyValue = _cast(None, latencyValue)
        self.latencyUnit = _cast(None, latencyUnit)
        self.frequencyDomain = _cast(None, frequencyDomain)
        self.voltageDomain = _cast(None, voltageDomain)
        self.dmaControllerPowerModel = _cast(None, dmaControllerPowerModel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DMAControllerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DMAControllerType.subclass:
            return DMAControllerType.subclass(*args_, **kwargs_)
        else:
            return DMAControllerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_channelCount(self): return self.channelCount
    def set_channelCount(self, channelCount): self.channelCount = channelCount
    def get_throughputValue(self): return self.throughputValue
    def set_throughputValue(self, throughputValue): self.throughputValue = throughputValue
    def get_throughputUnit(self): return self.throughputUnit
    def set_throughputUnit(self, throughputUnit): self.throughputUnit = throughputUnit
    def get_latencyValue(self): return self.latencyValue
    def set_latencyValue(self, latencyValue): self.latencyValue = latencyValue
    def get_latencyUnit(self): return self.latencyUnit
    def set_latencyUnit(self, latencyUnit): self.latencyUnit = latencyUnit
    def get_frequencyDomain(self): return self.frequencyDomain
    def set_frequencyDomain(self, frequencyDomain): self.frequencyDomain = frequencyDomain
    def get_voltageDomain(self): return self.voltageDomain
    def set_voltageDomain(self, voltageDomain): self.voltageDomain = voltageDomain
    def get_dmaControllerPowerModel(self): return self.dmaControllerPowerModel
    def set_dmaControllerPowerModel(self, dmaControllerPowerModel): self.dmaControllerPowerModel = dmaControllerPowerModel
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_PositiveIntType(self, value):
        # Validate type PositiveIntType, a restriction on xs:positiveInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ThroughputValueType(self, value):
        # Validate type ThroughputValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on ThroughputValueType' % {"value" : value} )
    def validate_ThroughputUnitType(self, value):
        # Validate type ThroughputUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bit/cycle', 'B/cycle', 'kB/cycle', 'KiB/cycle']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ThroughputUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CyclesValueType(self, value):
        # Validate type CyclesValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CyclesValueType' % {"value" : value} )
    def validate_CyclesUnitType(self, value):
        # Validate type CyclesUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cycles', 'kcycles', 'Mcycles']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CyclesUnitType' % {"value" : value.encode("utf-8")} )
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='DMAControllerType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DMAControllerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='DMAControllerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='DMAControllerType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.channelCount is not None and 'channelCount' not in already_processed:
            already_processed.add('channelCount')
            outfile.write(' channelCount=%s' % (quote_attrib(self.channelCount), ))
        if self.throughputValue is not None and 'throughputValue' not in already_processed:
            already_processed.add('throughputValue')
            outfile.write(' throughputValue=%s' % (quote_attrib(self.throughputValue), ))
        if self.throughputUnit != "bit/cycle" and 'throughputUnit' not in already_processed:
            already_processed.add('throughputUnit')
            outfile.write(' throughputUnit=%s' % (quote_attrib(self.throughputUnit), ))
        if self.latencyValue != "0" and 'latencyValue' not in already_processed:
            already_processed.add('latencyValue')
            outfile.write(' latencyValue=%s' % (quote_attrib(self.latencyValue), ))
        if self.latencyUnit != "cycles" and 'latencyUnit' not in already_processed:
            already_processed.add('latencyUnit')
            outfile.write(' latencyUnit=%s' % (quote_attrib(self.latencyUnit), ))
        if self.frequencyDomain is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            outfile.write(' frequencyDomain=%s' % (quote_attrib(self.frequencyDomain), ))
        if self.voltageDomain is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            outfile.write(' voltageDomain=%s' % (quote_attrib(self.voltageDomain), ))
        if self.dmaControllerPowerModel is not None and 'dmaControllerPowerModel' not in already_processed:
            already_processed.add('dmaControllerPowerModel')
            outfile.write(' dmaControllerPowerModel=%s' % (quote_attrib(self.dmaControllerPowerModel), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='DMAControllerType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('channelCount', node)
        if value is not None and 'channelCount' not in already_processed:
            already_processed.add('channelCount')
            try:
                self.channelCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.channelCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_PositiveIntType(self.channelCount)    # validate type PositiveIntType
        value = find_attr_value_('throughputValue', node)
        if value is not None and 'throughputValue' not in already_processed:
            already_processed.add('throughputValue')
            self.throughputValue = value
            self.validate_ThroughputValueType(self.throughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('throughputUnit', node)
        if value is not None and 'throughputUnit' not in already_processed:
            already_processed.add('throughputUnit')
            self.throughputUnit = value
            self.validate_ThroughputUnitType(self.throughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('latencyValue', node)
        if value is not None and 'latencyValue' not in already_processed:
            already_processed.add('latencyValue')
            self.latencyValue = value
            self.validate_CyclesValueType(self.latencyValue)    # validate type CyclesValueType
        value = find_attr_value_('latencyUnit', node)
        if value is not None and 'latencyUnit' not in already_processed:
            already_processed.add('latencyUnit')
            self.latencyUnit = value
            self.validate_CyclesUnitType(self.latencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('frequencyDomain', node)
        if value is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            self.frequencyDomain = value
            self.validate_RefType(self.frequencyDomain)    # validate type RefType
        value = find_attr_value_('voltageDomain', node)
        if value is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            self.voltageDomain = value
            self.validate_RefType(self.voltageDomain)    # validate type RefType
        value = find_attr_value_('dmaControllerPowerModel', node)
        if value is not None and 'dmaControllerPowerModel' not in already_processed:
            already_processed.add('dmaControllerPowerModel')
            self.dmaControllerPowerModel = value
            self.validate_RefType(self.dmaControllerPowerModel)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DMAControllerType


class DMAControllerRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dmaController=None):
        self.original_tagname_ = None
        self.dmaController = _cast(None, dmaController)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DMAControllerRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DMAControllerRefType.subclass:
            return DMAControllerRefType.subclass(*args_, **kwargs_)
        else:
            return DMAControllerRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dmaController(self): return self.dmaController
    def set_dmaController(self, dmaController): self.dmaController = dmaController
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='DMAControllerRefType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DMAControllerRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='DMAControllerRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='DMAControllerRefType'):
        if self.dmaController is not None and 'dmaController' not in already_processed:
            already_processed.add('dmaController')
            outfile.write(' dmaController=%s' % (quote_attrib(self.dmaController), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='DMAControllerRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dmaController', node)
        if value is not None and 'dmaController' not in already_processed:
            already_processed.add('dmaController')
            self.dmaController = value
            self.validate_RefType(self.dmaController)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DMAControllerRefType


class LogicalLinkType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, throughputValue=None, throughputUnit='bit/cycle', latencyValue='0', latencyUnit='cycles', frequencyDomain=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.throughputValue = _cast(None, throughputValue)
        self.throughputUnit = _cast(None, throughputUnit)
        self.latencyValue = _cast(None, latencyValue)
        self.latencyUnit = _cast(None, latencyUnit)
        self.frequencyDomain = _cast(None, frequencyDomain)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalLinkType.subclass:
            return LogicalLinkType.subclass(*args_, **kwargs_)
        else:
            return LogicalLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_throughputValue(self): return self.throughputValue
    def set_throughputValue(self, throughputValue): self.throughputValue = throughputValue
    def get_throughputUnit(self): return self.throughputUnit
    def set_throughputUnit(self, throughputUnit): self.throughputUnit = throughputUnit
    def get_latencyValue(self): return self.latencyValue
    def set_latencyValue(self, latencyValue): self.latencyValue = latencyValue
    def get_latencyUnit(self): return self.latencyUnit
    def set_latencyUnit(self, latencyUnit): self.latencyUnit = latencyUnit
    def get_frequencyDomain(self): return self.frequencyDomain
    def set_frequencyDomain(self, frequencyDomain): self.frequencyDomain = frequencyDomain
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_ThroughputValueType(self, value):
        # Validate type ThroughputValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on ThroughputValueType' % {"value" : value} )
    def validate_ThroughputUnitType(self, value):
        # Validate type ThroughputUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['bit/cycle', 'B/cycle', 'kB/cycle', 'KiB/cycle']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ThroughputUnitType' % {"value" : value.encode("utf-8")} )
    def validate_CyclesValueType(self, value):
        # Validate type CyclesValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on CyclesValueType' % {"value" : value} )
    def validate_CyclesUnitType(self, value):
        # Validate type CyclesUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['cycles', 'kcycles', 'Mcycles']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CyclesUnitType' % {"value" : value.encode("utf-8")} )
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='LogicalLinkType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogicalLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='LogicalLinkType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='LogicalLinkType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.throughputValue is not None and 'throughputValue' not in already_processed:
            already_processed.add('throughputValue')
            outfile.write(' throughputValue=%s' % (quote_attrib(self.throughputValue), ))
        if self.throughputUnit != "bit/cycle" and 'throughputUnit' not in already_processed:
            already_processed.add('throughputUnit')
            outfile.write(' throughputUnit=%s' % (quote_attrib(self.throughputUnit), ))
        if self.latencyValue != "0" and 'latencyValue' not in already_processed:
            already_processed.add('latencyValue')
            outfile.write(' latencyValue=%s' % (quote_attrib(self.latencyValue), ))
        if self.latencyUnit != "cycles" and 'latencyUnit' not in already_processed:
            already_processed.add('latencyUnit')
            outfile.write(' latencyUnit=%s' % (quote_attrib(self.latencyUnit), ))
        if self.frequencyDomain is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            outfile.write(' frequencyDomain=%s' % (quote_attrib(self.frequencyDomain), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='LogicalLinkType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('throughputValue', node)
        if value is not None and 'throughputValue' not in already_processed:
            already_processed.add('throughputValue')
            self.throughputValue = value
            self.validate_ThroughputValueType(self.throughputValue)    # validate type ThroughputValueType
        value = find_attr_value_('throughputUnit', node)
        if value is not None and 'throughputUnit' not in already_processed:
            already_processed.add('throughputUnit')
            self.throughputUnit = value
            self.validate_ThroughputUnitType(self.throughputUnit)    # validate type ThroughputUnitType
        value = find_attr_value_('latencyValue', node)
        if value is not None and 'latencyValue' not in already_processed:
            already_processed.add('latencyValue')
            self.latencyValue = value
            self.validate_CyclesValueType(self.latencyValue)    # validate type CyclesValueType
        value = find_attr_value_('latencyUnit', node)
        if value is not None and 'latencyUnit' not in already_processed:
            already_processed.add('latencyUnit')
            self.latencyUnit = value
            self.validate_CyclesUnitType(self.latencyUnit)    # validate type CyclesUnitType
        value = find_attr_value_('frequencyDomain', node)
        if value is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            self.frequencyDomain = value
            self.validate_RefType(self.frequencyDomain)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LogicalLinkType


class LogicalLinkRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, logicalLink=None):
        self.original_tagname_ = None
        self.logicalLink = _cast(None, logicalLink)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalLinkRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalLinkRefType.subclass:
            return LogicalLinkRefType.subclass(*args_, **kwargs_)
        else:
            return LogicalLinkRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_logicalLink(self): return self.logicalLink
    def set_logicalLink(self, logicalLink): self.logicalLink = logicalLink
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='LogicalLinkRefType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogicalLinkRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='LogicalLinkRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='LogicalLinkRefType'):
        if self.logicalLink is not None and 'logicalLink' not in already_processed:
            already_processed.add('logicalLink')
            outfile.write(' logicalLink=%s' % (quote_attrib(self.logicalLink), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='LogicalLinkRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('logicalLink', node)
        if value is not None and 'logicalLink' not in already_processed:
            already_processed.add('logicalLink')
            self.logicalLink = value
            self.validate_RefType(self.logicalLink)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LogicalLinkRefType


class CommunicationBufferType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MemoryRef=None, FifoRef=None, CacheRef=None):
        self.original_tagname_ = None
        if MemoryRef is None:
            self.MemoryRef = []
        else:
            self.MemoryRef = MemoryRef
        if FifoRef is None:
            self.FifoRef = []
        else:
            self.FifoRef = FifoRef
        if CacheRef is None:
            self.CacheRef = []
        else:
            self.CacheRef = CacheRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommunicationBufferType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommunicationBufferType.subclass:
            return CommunicationBufferType.subclass(*args_, **kwargs_)
        else:
            return CommunicationBufferType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MemoryRef(self): return self.MemoryRef
    def set_MemoryRef(self, MemoryRef): self.MemoryRef = MemoryRef
    def add_MemoryRef(self, value): self.MemoryRef.append(value)
    def insert_MemoryRef_at(self, index, value): self.MemoryRef.insert(index, value)
    def replace_MemoryRef_at(self, index, value): self.MemoryRef[index] = value
    def get_FifoRef(self): return self.FifoRef
    def set_FifoRef(self, FifoRef): self.FifoRef = FifoRef
    def add_FifoRef(self, value): self.FifoRef.append(value)
    def insert_FifoRef_at(self, index, value): self.FifoRef.insert(index, value)
    def replace_FifoRef_at(self, index, value): self.FifoRef[index] = value
    def get_CacheRef(self): return self.CacheRef
    def set_CacheRef(self, CacheRef): self.CacheRef = CacheRef
    def add_CacheRef(self, value): self.CacheRef.append(value)
    def insert_CacheRef_at(self, index, value): self.CacheRef.insert(index, value)
    def replace_CacheRef_at(self, index, value): self.CacheRef[index] = value
    def hasContent_(self):
        if (
            self.MemoryRef or
            self.FifoRef or
            self.CacheRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CommunicationBufferType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommunicationBufferType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CommunicationBufferType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CommunicationBufferType'):
        pass
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CommunicationBufferType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MemoryRef_ in self.MemoryRef:
            MemoryRef_.export(outfile, level, namespace_, name_='MemoryRef', pretty_print=pretty_print)
        for FifoRef_ in self.FifoRef:
            FifoRef_.export(outfile, level, namespace_, name_='FifoRef', pretty_print=pretty_print)
        for CacheRef_ in self.CacheRef:
            CacheRef_.export(outfile, level, namespace_, name_='CacheRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MemoryRef':
            class_obj_ = self.get_class_obj_(child_, MemoryRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.MemoryRef.append(obj_)
            obj_.original_tagname_ = 'MemoryRef'
        elif nodeName_ == 'FifoRef':
            class_obj_ = self.get_class_obj_(child_, FifoRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.FifoRef.append(obj_)
            obj_.original_tagname_ = 'FifoRef'
        elif nodeName_ == 'CacheRef':
            class_obj_ = self.get_class_obj_(child_, CacheRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.CacheRef.append(obj_)
            obj_.original_tagname_ = 'CacheRef'
# end class CommunicationBufferType


class CommunicationPhaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MemoryAccess=None, CacheAccess=None, FifoAccess=None, PhysicalLinkRef=None, DMAControllerRef=None, LogicalLinkRef=None):
        self.original_tagname_ = None
        if MemoryAccess is None:
            self.MemoryAccess = []
        else:
            self.MemoryAccess = MemoryAccess
        if CacheAccess is None:
            self.CacheAccess = []
        else:
            self.CacheAccess = CacheAccess
        if FifoAccess is None:
            self.FifoAccess = []
        else:
            self.FifoAccess = FifoAccess
        if PhysicalLinkRef is None:
            self.PhysicalLinkRef = []
        else:
            self.PhysicalLinkRef = PhysicalLinkRef
        if DMAControllerRef is None:
            self.DMAControllerRef = []
        else:
            self.DMAControllerRef = DMAControllerRef
        if LogicalLinkRef is None:
            self.LogicalLinkRef = []
        else:
            self.LogicalLinkRef = LogicalLinkRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommunicationPhaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommunicationPhaseType.subclass:
            return CommunicationPhaseType.subclass(*args_, **kwargs_)
        else:
            return CommunicationPhaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MemoryAccess(self): return self.MemoryAccess
    def set_MemoryAccess(self, MemoryAccess): self.MemoryAccess = MemoryAccess
    def add_MemoryAccess(self, value): self.MemoryAccess.append(value)
    def insert_MemoryAccess_at(self, index, value): self.MemoryAccess.insert(index, value)
    def replace_MemoryAccess_at(self, index, value): self.MemoryAccess[index] = value
    def get_CacheAccess(self): return self.CacheAccess
    def set_CacheAccess(self, CacheAccess): self.CacheAccess = CacheAccess
    def add_CacheAccess(self, value): self.CacheAccess.append(value)
    def insert_CacheAccess_at(self, index, value): self.CacheAccess.insert(index, value)
    def replace_CacheAccess_at(self, index, value): self.CacheAccess[index] = value
    def get_FifoAccess(self): return self.FifoAccess
    def set_FifoAccess(self, FifoAccess): self.FifoAccess = FifoAccess
    def add_FifoAccess(self, value): self.FifoAccess.append(value)
    def insert_FifoAccess_at(self, index, value): self.FifoAccess.insert(index, value)
    def replace_FifoAccess_at(self, index, value): self.FifoAccess[index] = value
    def get_PhysicalLinkRef(self): return self.PhysicalLinkRef
    def set_PhysicalLinkRef(self, PhysicalLinkRef): self.PhysicalLinkRef = PhysicalLinkRef
    def add_PhysicalLinkRef(self, value): self.PhysicalLinkRef.append(value)
    def insert_PhysicalLinkRef_at(self, index, value): self.PhysicalLinkRef.insert(index, value)
    def replace_PhysicalLinkRef_at(self, index, value): self.PhysicalLinkRef[index] = value
    def get_DMAControllerRef(self): return self.DMAControllerRef
    def set_DMAControllerRef(self, DMAControllerRef): self.DMAControllerRef = DMAControllerRef
    def add_DMAControllerRef(self, value): self.DMAControllerRef.append(value)
    def insert_DMAControllerRef_at(self, index, value): self.DMAControllerRef.insert(index, value)
    def replace_DMAControllerRef_at(self, index, value): self.DMAControllerRef[index] = value
    def get_LogicalLinkRef(self): return self.LogicalLinkRef
    def set_LogicalLinkRef(self, LogicalLinkRef): self.LogicalLinkRef = LogicalLinkRef
    def add_LogicalLinkRef(self, value): self.LogicalLinkRef.append(value)
    def insert_LogicalLinkRef_at(self, index, value): self.LogicalLinkRef.insert(index, value)
    def replace_LogicalLinkRef_at(self, index, value): self.LogicalLinkRef[index] = value
    def hasContent_(self):
        if (
            self.MemoryAccess or
            self.CacheAccess or
            self.FifoAccess or
            self.PhysicalLinkRef or
            self.DMAControllerRef or
            self.LogicalLinkRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CommunicationPhaseType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommunicationPhaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CommunicationPhaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CommunicationPhaseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CommunicationPhaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MemoryAccess_ in self.MemoryAccess:
            MemoryAccess_.export(outfile, level, namespace_, name_='MemoryAccess', pretty_print=pretty_print)
        for CacheAccess_ in self.CacheAccess:
            CacheAccess_.export(outfile, level, namespace_, name_='CacheAccess', pretty_print=pretty_print)
        for FifoAccess_ in self.FifoAccess:
            FifoAccess_.export(outfile, level, namespace_, name_='FifoAccess', pretty_print=pretty_print)
        for PhysicalLinkRef_ in self.PhysicalLinkRef:
            PhysicalLinkRef_.export(outfile, level, namespace_, name_='PhysicalLinkRef', pretty_print=pretty_print)
        for DMAControllerRef_ in self.DMAControllerRef:
            DMAControllerRef_.export(outfile, level, namespace_, name_='DMAControllerRef', pretty_print=pretty_print)
        for LogicalLinkRef_ in self.LogicalLinkRef:
            LogicalLinkRef_.export(outfile, level, namespace_, name_='LogicalLinkRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MemoryAccess':
            obj_ = MemoryAccessType.factory()
            obj_.build(child_)
            self.MemoryAccess.append(obj_)
            obj_.original_tagname_ = 'MemoryAccess'
        elif nodeName_ == 'CacheAccess':
            obj_ = CacheAccessType.factory()
            obj_.build(child_)
            self.CacheAccess.append(obj_)
            obj_.original_tagname_ = 'CacheAccess'
        elif nodeName_ == 'FifoAccess':
            obj_ = FifoAccessType.factory()
            obj_.build(child_)
            self.FifoAccess.append(obj_)
            obj_.original_tagname_ = 'FifoAccess'
        elif nodeName_ == 'PhysicalLinkRef':
            obj_ = PhysicalLinkRefType.factory()
            obj_.build(child_)
            self.PhysicalLinkRef.append(obj_)
            obj_.original_tagname_ = 'PhysicalLinkRef'
        elif nodeName_ == 'DMAControllerRef':
            obj_ = DMAControllerRefType.factory()
            obj_.build(child_)
            self.DMAControllerRef.append(obj_)
            obj_.original_tagname_ = 'DMAControllerRef'
        elif nodeName_ == 'LogicalLinkRef':
            obj_ = LogicalLinkRefType.factory()
            obj_.build(child_)
            self.LogicalLinkRef.append(obj_)
            obj_.original_tagname_ = 'LogicalLinkRef'
# end class CommunicationPhaseType


class CommunicationProducerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, processor=None, Buffer=None, Active=None, Passive=None):
        self.original_tagname_ = None
        self.processor = _cast(None, processor)
        self.Buffer = Buffer
        self.Active = Active
        self.Passive = Passive
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommunicationProducerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommunicationProducerType.subclass:
            return CommunicationProducerType.subclass(*args_, **kwargs_)
        else:
            return CommunicationProducerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Buffer(self): return self.Buffer
    def set_Buffer(self, Buffer): self.Buffer = Buffer
    def get_Active(self): return self.Active
    def set_Active(self, Active): self.Active = Active
    def get_Passive(self): return self.Passive
    def set_Passive(self, Passive): self.Passive = Passive
    def get_processor(self): return self.processor
    def set_processor(self, processor): self.processor = processor
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (
            self.Buffer is not None or
            self.Active is not None or
            self.Passive is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CommunicationProducerType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommunicationProducerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CommunicationProducerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CommunicationProducerType'):
        if self.processor is not None and 'processor' not in already_processed:
            already_processed.add('processor')
            outfile.write(' processor=%s' % (quote_attrib(self.processor), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CommunicationProducerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Buffer is not None:
            self.Buffer.export(outfile, level, namespace_, name_='Buffer', pretty_print=pretty_print)
        if self.Active is not None:
            self.Active.export(outfile, level, namespace_, name_='Active', pretty_print=pretty_print)
        if self.Passive is not None:
            self.Passive.export(outfile, level, namespace_, name_='Passive', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('processor', node)
        if value is not None and 'processor' not in already_processed:
            already_processed.add('processor')
            self.processor = value
            self.validate_RefType(self.processor)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Buffer':
            obj_ = CommunicationBufferType.factory()
            obj_.build(child_)
            self.Buffer = obj_
            obj_.original_tagname_ = 'Buffer'
        elif nodeName_ == 'Active':
            obj_ = CommunicationPhaseType.factory()
            obj_.build(child_)
            self.Active = obj_
            obj_.original_tagname_ = 'Active'
        elif nodeName_ == 'Passive':
            obj_ = CommunicationPhaseType.factory()
            obj_.build(child_)
            self.Passive = obj_
            obj_.original_tagname_ = 'Passive'
# end class CommunicationProducerType


class CommunicationConsumerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, processor=None, Buffer=None, Passive=None, Active=None):
        self.original_tagname_ = None
        self.processor = _cast(None, processor)
        self.Buffer = Buffer
        self.Passive = Passive
        self.Active = Active
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommunicationConsumerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommunicationConsumerType.subclass:
            return CommunicationConsumerType.subclass(*args_, **kwargs_)
        else:
            return CommunicationConsumerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Buffer(self): return self.Buffer
    def set_Buffer(self, Buffer): self.Buffer = Buffer
    def get_Passive(self): return self.Passive
    def set_Passive(self, Passive): self.Passive = Passive
    def get_Active(self): return self.Active
    def set_Active(self, Active): self.Active = Active
    def get_processor(self): return self.processor
    def set_processor(self, processor): self.processor = processor
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (
            self.Buffer is not None or
            self.Passive is not None or
            self.Active is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CommunicationConsumerType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommunicationConsumerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CommunicationConsumerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CommunicationConsumerType'):
        if self.processor is not None and 'processor' not in already_processed:
            already_processed.add('processor')
            outfile.write(' processor=%s' % (quote_attrib(self.processor), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CommunicationConsumerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Buffer is not None:
            self.Buffer.export(outfile, level, namespace_, name_='Buffer', pretty_print=pretty_print)
        if self.Passive is not None:
            self.Passive.export(outfile, level, namespace_, name_='Passive', pretty_print=pretty_print)
        if self.Active is not None:
            self.Active.export(outfile, level, namespace_, name_='Active', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('processor', node)
        if value is not None and 'processor' not in already_processed:
            already_processed.add('processor')
            self.processor = value
            self.validate_RefType(self.processor)    # validate type RefType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Buffer':
            obj_ = CommunicationBufferType.factory()
            obj_.build(child_)
            self.Buffer = obj_
            obj_.original_tagname_ = 'Buffer'
        elif nodeName_ == 'Passive':
            obj_ = CommunicationPhaseType.factory()
            obj_.build(child_)
            self.Passive = obj_
            obj_.original_tagname_ = 'Passive'
        elif nodeName_ == 'Active':
            obj_ = CommunicationPhaseType.factory()
            obj_.build(child_)
            self.Active = obj_
            obj_.original_tagname_ = 'Active'
# end class CommunicationConsumerType


class CommunicationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, multicast=None, flags=None, Buffer=None, Producer=None, Consumer=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.multicast = _cast(None, multicast)
        self.flags = _cast(None, flags)
        self.Buffer = Buffer
        if Producer is None:
            self.Producer = []
        else:
            self.Producer = Producer
        if Consumer is None:
            self.Consumer = []
        else:
            self.Consumer = Consumer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommunicationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommunicationType.subclass:
            return CommunicationType.subclass(*args_, **kwargs_)
        else:
            return CommunicationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Buffer(self): return self.Buffer
    def set_Buffer(self, Buffer): self.Buffer = Buffer
    def get_Producer(self): return self.Producer
    def set_Producer(self, Producer): self.Producer = Producer
    def add_Producer(self, value): self.Producer.append(value)
    def insert_Producer_at(self, index, value): self.Producer.insert(index, value)
    def replace_Producer_at(self, index, value): self.Producer[index] = value
    def get_Consumer(self): return self.Consumer
    def set_Consumer(self, Consumer): self.Consumer = Consumer
    def add_Consumer(self, value): self.Consumer.append(value)
    def insert_Consumer_at(self, index, value): self.Consumer.insert(index, value)
    def replace_Consumer_at(self, index, value): self.Consumer[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_multicast(self): return self.multicast
    def set_multicast(self, multicast): self.multicast = multicast
    def get_flags(self): return self.flags
    def set_flags(self, flags): self.flags = flags
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_BooleanType(self, value):
        # Validate type BooleanType, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_FlagListType(self, value):
        # Validate type FlagListType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_FlagListType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_FlagListType_patterns_, ))
    validate_FlagListType_patterns_ = [['^[a-zA-Z0-9_.,]+$']]
    def hasContent_(self):
        if (
            self.Buffer is not None or
            self.Producer or
            self.Consumer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='CommunicationType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommunicationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='CommunicationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='CommunicationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.multicast is not None and 'multicast' not in already_processed:
            already_processed.add('multicast')
            outfile.write(' multicast=%s' % (quote_attrib(self.multicast), ))
        if self.flags is not None and 'flags' not in already_processed:
            already_processed.add('flags')
            outfile.write(' flags=%s' % (quote_attrib(self.flags), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='CommunicationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Buffer is not None:
            self.Buffer.export(outfile, level, namespace_, name_='Buffer', pretty_print=pretty_print)
        for Producer_ in self.Producer:
            Producer_.export(outfile, level, namespace_, name_='Producer', pretty_print=pretty_print)
        for Consumer_ in self.Consumer:
            Consumer_.export(outfile, level, namespace_, name_='Consumer', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('multicast', node)
        if value is not None and 'multicast' not in already_processed:
            already_processed.add('multicast')
            if value in ('true', '1'):
                self.multicast = True
            elif value in ('false', '0'):
                self.multicast = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_BooleanType(self.multicast)    # validate type BooleanType
        value = find_attr_value_('flags', node)
        if value is not None and 'flags' not in already_processed:
            already_processed.add('flags')
            self.flags = value
            self.validate_FlagListType(self.flags)    # validate type FlagListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Buffer':
            obj_ = CommunicationBufferType.factory()
            obj_.build(child_)
            self.Buffer = obj_
            obj_.original_tagname_ = 'Buffer'
        elif nodeName_ == 'Producer':
            obj_ = CommunicationProducerType.factory()
            obj_.build(child_)
            self.Producer.append(obj_)
            obj_.original_tagname_ = 'Producer'
        elif nodeName_ == 'Consumer':
            obj_ = CommunicationConsumerType.factory()
            obj_.build(child_)
            self.Consumer.append(obj_)
            obj_.original_tagname_ = 'Consumer'
# end class CommunicationType


class PeripheralEmulatorLibraryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, library=None, init=None, exit=None, read=None, write=None):
        self.original_tagname_ = None
        self.library = _cast(None, library)
        self.init = _cast(None, init)
        self.exit = _cast(None, exit)
        self.read = _cast(None, read)
        self.write = _cast(None, write)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PeripheralEmulatorLibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PeripheralEmulatorLibraryType.subclass:
            return PeripheralEmulatorLibraryType.subclass(*args_, **kwargs_)
        else:
            return PeripheralEmulatorLibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_init(self): return self.init
    def set_init(self, init): self.init = init
    def get_exit(self): return self.exit
    def set_exit(self, exit): self.exit = exit
    def get_read(self): return self.read
    def set_read(self, read): self.read = read
    def get_write(self): return self.write
    def set_write(self, write): self.write = write
    def validate_FileNameType(self, value):
        # Validate type FileNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_NameType(self, value):
        # Validate type NameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NameType_patterns_, ))
    validate_NameType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='PeripheralEmulatorLibraryType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PeripheralEmulatorLibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='PeripheralEmulatorLibraryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='PeripheralEmulatorLibraryType'):
        if self.library is not None and 'library' not in already_processed:
            already_processed.add('library')
            outfile.write(' library=%s' % (quote_attrib(self.library), ))
        if self.init is not None and 'init' not in already_processed:
            already_processed.add('init')
            outfile.write(' init=%s' % (quote_attrib(self.init), ))
        if self.exit is not None and 'exit' not in already_processed:
            already_processed.add('exit')
            outfile.write(' exit=%s' % (quote_attrib(self.exit), ))
        if self.read is not None and 'read' not in already_processed:
            already_processed.add('read')
            outfile.write(' read=%s' % (quote_attrib(self.read), ))
        if self.write is not None and 'write' not in already_processed:
            already_processed.add('write')
            outfile.write(' write=%s' % (quote_attrib(self.write), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='PeripheralEmulatorLibraryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.add('library')
            self.library = value
            self.validate_FileNameType(self.library)    # validate type FileNameType
        value = find_attr_value_('init', node)
        if value is not None and 'init' not in already_processed:
            already_processed.add('init')
            self.init = value
            self.validate_NameType(self.init)    # validate type NameType
        value = find_attr_value_('exit', node)
        if value is not None and 'exit' not in already_processed:
            already_processed.add('exit')
            self.exit = value
            self.validate_NameType(self.exit)    # validate type NameType
        value = find_attr_value_('read', node)
        if value is not None and 'read' not in already_processed:
            already_processed.add('read')
            self.read = value
            self.validate_NameType(self.read)    # validate type NameType
        value = find_attr_value_('write', node)
        if value is not None and 'write' not in already_processed:
            already_processed.add('write')
            self.write = value
            self.validate_NameType(self.write)    # validate type NameType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PeripheralEmulatorLibraryType


class PeripheralType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, startAddress=None, endAddress=None, PeripheralEmulatorLibrary=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.startAddress = _cast(None, startAddress)
        self.endAddress = _cast(None, endAddress)
        self.PeripheralEmulatorLibrary = PeripheralEmulatorLibrary
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PeripheralType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PeripheralType.subclass:
            return PeripheralType.subclass(*args_, **kwargs_)
        else:
            return PeripheralType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PeripheralEmulatorLibrary(self): return self.PeripheralEmulatorLibrary
    def set_PeripheralEmulatorLibrary(self, PeripheralEmulatorLibrary): self.PeripheralEmulatorLibrary = PeripheralEmulatorLibrary
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_startAddress(self): return self.startAddress
    def set_startAddress(self, startAddress): self.startAddress = startAddress
    def get_endAddress(self): return self.endAddress
    def set_endAddress(self, endAddress): self.endAddress = endAddress
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_AddressType(self, value):
        # Validate type AddressType, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.PeripheralEmulatorLibrary is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='PeripheralType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PeripheralType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='PeripheralType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='PeripheralType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.startAddress is not None and 'startAddress' not in already_processed:
            already_processed.add('startAddress')
            outfile.write(' startAddress=%s' % (quote_attrib(self.startAddress), ))
        if self.endAddress is not None and 'endAddress' not in already_processed:
            already_processed.add('endAddress')
            outfile.write(' endAddress=%s' % (quote_attrib(self.endAddress), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='PeripheralType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PeripheralEmulatorLibrary is not None:
            self.PeripheralEmulatorLibrary.export(outfile, level, namespace_, name_='PeripheralEmulatorLibrary', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        value = find_attr_value_('startAddress', node)
        if value is not None and 'startAddress' not in already_processed:
            already_processed.add('startAddress')
            self.startAddress = value
            self.validate_AddressType(self.startAddress)    # validate type AddressType
        value = find_attr_value_('endAddress', node)
        if value is not None and 'endAddress' not in already_processed:
            already_processed.add('endAddress')
            self.endAddress = value
            self.validate_AddressType(self.endAddress)    # validate type AddressType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PeripheralEmulatorLibrary':
            obj_ = PeripheralEmulatorLibraryType.factory()
            obj_.build(child_)
            self.PeripheralEmulatorLibrary = obj_
            obj_.original_tagname_ = 'PeripheralEmulatorLibrary'
# end class PeripheralType


class SubsystemPlatformType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Subsystem=None, VoltageDomain=None, FrequencyDomain=None, SchedulingPolicyList=None, Scheduler=None, ProcessorPowerModel=None, Processor=None, MemoryPowerModel=None, Memory=None, CachePowerModel=None, Cache=None, FifoPowerModel=None, Fifo=None, PhysicalLinkPowerModel=None, PhysicalLink=None, DMAControllerPowerModel=None, DMAController=None, LogicalLink=None, Communication=None, Peripheral=None, extensiontype_=None):
        self.original_tagname_ = None
        if Subsystem is None:
            self.Subsystem = []
        else:
            self.Subsystem = Subsystem
        if VoltageDomain is None:
            self.VoltageDomain = []
        else:
            self.VoltageDomain = VoltageDomain
        if FrequencyDomain is None:
            self.FrequencyDomain = []
        else:
            self.FrequencyDomain = FrequencyDomain
        if SchedulingPolicyList is None:
            self.SchedulingPolicyList = []
        else:
            self.SchedulingPolicyList = SchedulingPolicyList
        if Scheduler is None:
            self.Scheduler = []
        else:
            self.Scheduler = Scheduler
        if ProcessorPowerModel is None:
            self.ProcessorPowerModel = []
        else:
            self.ProcessorPowerModel = ProcessorPowerModel
        if Processor is None:
            self.Processor = []
        else:
            self.Processor = Processor
        if MemoryPowerModel is None:
            self.MemoryPowerModel = []
        else:
            self.MemoryPowerModel = MemoryPowerModel
        if Memory is None:
            self.Memory = []
        else:
            self.Memory = Memory
        if CachePowerModel is None:
            self.CachePowerModel = []
        else:
            self.CachePowerModel = CachePowerModel
        if Cache is None:
            self.Cache = []
        else:
            self.Cache = Cache
        if FifoPowerModel is None:
            self.FifoPowerModel = []
        else:
            self.FifoPowerModel = FifoPowerModel
        if Fifo is None:
            self.Fifo = []
        else:
            self.Fifo = Fifo
        if PhysicalLinkPowerModel is None:
            self.PhysicalLinkPowerModel = []
        else:
            self.PhysicalLinkPowerModel = PhysicalLinkPowerModel
        if PhysicalLink is None:
            self.PhysicalLink = []
        else:
            self.PhysicalLink = PhysicalLink
        if DMAControllerPowerModel is None:
            self.DMAControllerPowerModel = []
        else:
            self.DMAControllerPowerModel = DMAControllerPowerModel
        if DMAController is None:
            self.DMAController = []
        else:
            self.DMAController = DMAController
        if LogicalLink is None:
            self.LogicalLink = []
        else:
            self.LogicalLink = LogicalLink
        if Communication is None:
            self.Communication = []
        else:
            self.Communication = Communication
        if Peripheral is None:
            self.Peripheral = []
        else:
            self.Peripheral = Peripheral
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubsystemPlatformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubsystemPlatformType.subclass:
            return SubsystemPlatformType.subclass(*args_, **kwargs_)
        else:
            return SubsystemPlatformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Subsystem(self): return self.Subsystem
    def set_Subsystem(self, Subsystem): self.Subsystem = Subsystem
    def add_Subsystem(self, value): self.Subsystem.append(value)
    def insert_Subsystem_at(self, index, value): self.Subsystem.insert(index, value)
    def replace_Subsystem_at(self, index, value): self.Subsystem[index] = value
    def get_VoltageDomain(self): return self.VoltageDomain
    def set_VoltageDomain(self, VoltageDomain): self.VoltageDomain = VoltageDomain
    def add_VoltageDomain(self, value): self.VoltageDomain.append(value)
    def insert_VoltageDomain_at(self, index, value): self.VoltageDomain.insert(index, value)
    def replace_VoltageDomain_at(self, index, value): self.VoltageDomain[index] = value
    def get_FrequencyDomain(self): return self.FrequencyDomain
    def set_FrequencyDomain(self, FrequencyDomain): self.FrequencyDomain = FrequencyDomain
    def add_FrequencyDomain(self, value): self.FrequencyDomain.append(value)
    def insert_FrequencyDomain_at(self, index, value): self.FrequencyDomain.insert(index, value)
    def replace_FrequencyDomain_at(self, index, value): self.FrequencyDomain[index] = value
    def get_SchedulingPolicyList(self): return self.SchedulingPolicyList
    def set_SchedulingPolicyList(self, SchedulingPolicyList): self.SchedulingPolicyList = SchedulingPolicyList
    def add_SchedulingPolicyList(self, value): self.SchedulingPolicyList.append(value)
    def insert_SchedulingPolicyList_at(self, index, value): self.SchedulingPolicyList.insert(index, value)
    def replace_SchedulingPolicyList_at(self, index, value): self.SchedulingPolicyList[index] = value
    def get_Scheduler(self): return self.Scheduler
    def set_Scheduler(self, Scheduler): self.Scheduler = Scheduler
    def add_Scheduler(self, value): self.Scheduler.append(value)
    def insert_Scheduler_at(self, index, value): self.Scheduler.insert(index, value)
    def replace_Scheduler_at(self, index, value): self.Scheduler[index] = value
    def get_ProcessorPowerModel(self): return self.ProcessorPowerModel
    def set_ProcessorPowerModel(self, ProcessorPowerModel): self.ProcessorPowerModel = ProcessorPowerModel
    def add_ProcessorPowerModel(self, value): self.ProcessorPowerModel.append(value)
    def insert_ProcessorPowerModel_at(self, index, value): self.ProcessorPowerModel.insert(index, value)
    def replace_ProcessorPowerModel_at(self, index, value): self.ProcessorPowerModel[index] = value
    def get_Processor(self): return self.Processor
    def set_Processor(self, Processor): self.Processor = Processor
    def add_Processor(self, value): self.Processor.append(value)
    def insert_Processor_at(self, index, value): self.Processor.insert(index, value)
    def replace_Processor_at(self, index, value): self.Processor[index] = value
    def get_MemoryPowerModel(self): return self.MemoryPowerModel
    def set_MemoryPowerModel(self, MemoryPowerModel): self.MemoryPowerModel = MemoryPowerModel
    def add_MemoryPowerModel(self, value): self.MemoryPowerModel.append(value)
    def insert_MemoryPowerModel_at(self, index, value): self.MemoryPowerModel.insert(index, value)
    def replace_MemoryPowerModel_at(self, index, value): self.MemoryPowerModel[index] = value
    def get_Memory(self): return self.Memory
    def set_Memory(self, Memory): self.Memory = Memory
    def add_Memory(self, value): self.Memory.append(value)
    def insert_Memory_at(self, index, value): self.Memory.insert(index, value)
    def replace_Memory_at(self, index, value): self.Memory[index] = value
    def get_CachePowerModel(self): return self.CachePowerModel
    def set_CachePowerModel(self, CachePowerModel): self.CachePowerModel = CachePowerModel
    def add_CachePowerModel(self, value): self.CachePowerModel.append(value)
    def insert_CachePowerModel_at(self, index, value): self.CachePowerModel.insert(index, value)
    def replace_CachePowerModel_at(self, index, value): self.CachePowerModel[index] = value
    def get_Cache(self): return self.Cache
    def set_Cache(self, Cache): self.Cache = Cache
    def add_Cache(self, value): self.Cache.append(value)
    def insert_Cache_at(self, index, value): self.Cache.insert(index, value)
    def replace_Cache_at(self, index, value): self.Cache[index] = value
    def get_FifoPowerModel(self): return self.FifoPowerModel
    def set_FifoPowerModel(self, FifoPowerModel): self.FifoPowerModel = FifoPowerModel
    def add_FifoPowerModel(self, value): self.FifoPowerModel.append(value)
    def insert_FifoPowerModel_at(self, index, value): self.FifoPowerModel.insert(index, value)
    def replace_FifoPowerModel_at(self, index, value): self.FifoPowerModel[index] = value
    def get_Fifo(self): return self.Fifo
    def set_Fifo(self, Fifo): self.Fifo = Fifo
    def add_Fifo(self, value): self.Fifo.append(value)
    def insert_Fifo_at(self, index, value): self.Fifo.insert(index, value)
    def replace_Fifo_at(self, index, value): self.Fifo[index] = value
    def get_PhysicalLinkPowerModel(self): return self.PhysicalLinkPowerModel
    def set_PhysicalLinkPowerModel(self, PhysicalLinkPowerModel): self.PhysicalLinkPowerModel = PhysicalLinkPowerModel
    def add_PhysicalLinkPowerModel(self, value): self.PhysicalLinkPowerModel.append(value)
    def insert_PhysicalLinkPowerModel_at(self, index, value): self.PhysicalLinkPowerModel.insert(index, value)
    def replace_PhysicalLinkPowerModel_at(self, index, value): self.PhysicalLinkPowerModel[index] = value
    def get_PhysicalLink(self): return self.PhysicalLink
    def set_PhysicalLink(self, PhysicalLink): self.PhysicalLink = PhysicalLink
    def add_PhysicalLink(self, value): self.PhysicalLink.append(value)
    def insert_PhysicalLink_at(self, index, value): self.PhysicalLink.insert(index, value)
    def replace_PhysicalLink_at(self, index, value): self.PhysicalLink[index] = value
    def get_DMAControllerPowerModel(self): return self.DMAControllerPowerModel
    def set_DMAControllerPowerModel(self, DMAControllerPowerModel): self.DMAControllerPowerModel = DMAControllerPowerModel
    def add_DMAControllerPowerModel(self, value): self.DMAControllerPowerModel.append(value)
    def insert_DMAControllerPowerModel_at(self, index, value): self.DMAControllerPowerModel.insert(index, value)
    def replace_DMAControllerPowerModel_at(self, index, value): self.DMAControllerPowerModel[index] = value
    def get_DMAController(self): return self.DMAController
    def set_DMAController(self, DMAController): self.DMAController = DMAController
    def add_DMAController(self, value): self.DMAController.append(value)
    def insert_DMAController_at(self, index, value): self.DMAController.insert(index, value)
    def replace_DMAController_at(self, index, value): self.DMAController[index] = value
    def get_LogicalLink(self): return self.LogicalLink
    def set_LogicalLink(self, LogicalLink): self.LogicalLink = LogicalLink
    def add_LogicalLink(self, value): self.LogicalLink.append(value)
    def insert_LogicalLink_at(self, index, value): self.LogicalLink.insert(index, value)
    def replace_LogicalLink_at(self, index, value): self.LogicalLink[index] = value
    def get_Communication(self): return self.Communication
    def set_Communication(self, Communication): self.Communication = Communication
    def add_Communication(self, value): self.Communication.append(value)
    def insert_Communication_at(self, index, value): self.Communication.insert(index, value)
    def replace_Communication_at(self, index, value): self.Communication[index] = value
    def get_Peripheral(self): return self.Peripheral
    def set_Peripheral(self, Peripheral): self.Peripheral = Peripheral
    def add_Peripheral(self, value): self.Peripheral.append(value)
    def insert_Peripheral_at(self, index, value): self.Peripheral.insert(index, value)
    def replace_Peripheral_at(self, index, value): self.Peripheral[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Subsystem or
            self.VoltageDomain or
            self.FrequencyDomain or
            self.SchedulingPolicyList or
            self.Scheduler or
            self.ProcessorPowerModel or
            self.Processor or
            self.MemoryPowerModel or
            self.Memory or
            self.CachePowerModel or
            self.Cache or
            self.FifoPowerModel or
            self.Fifo or
            self.PhysicalLinkPowerModel or
            self.PhysicalLink or
            self.DMAControllerPowerModel or
            self.DMAController or
            self.LogicalLink or
            self.Communication or
            self.Peripheral
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='SubsystemPlatformType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubsystemPlatformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='SubsystemPlatformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='SubsystemPlatformType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='SubsystemPlatformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Subsystem_ in self.Subsystem:
            Subsystem_.export(outfile, level, namespace_, name_='Subsystem', pretty_print=pretty_print)
        for VoltageDomain_ in self.VoltageDomain:
            VoltageDomain_.export(outfile, level, namespace_, name_='VoltageDomain', pretty_print=pretty_print)
        for FrequencyDomain_ in self.FrequencyDomain:
            FrequencyDomain_.export(outfile, level, namespace_, name_='FrequencyDomain', pretty_print=pretty_print)
        for SchedulingPolicyList_ in self.SchedulingPolicyList:
            SchedulingPolicyList_.export(outfile, level, namespace_, name_='SchedulingPolicyList', pretty_print=pretty_print)
        for Scheduler_ in self.Scheduler:
            Scheduler_.export(outfile, level, namespace_, name_='Scheduler', pretty_print=pretty_print)
        for ProcessorPowerModel_ in self.ProcessorPowerModel:
            ProcessorPowerModel_.export(outfile, level, namespace_, name_='ProcessorPowerModel', pretty_print=pretty_print)
        for Processor_ in self.Processor:
            Processor_.export(outfile, level, namespace_, name_='Processor', pretty_print=pretty_print)
        for MemoryPowerModel_ in self.MemoryPowerModel:
            MemoryPowerModel_.export(outfile, level, namespace_, name_='MemoryPowerModel', pretty_print=pretty_print)
        for Memory_ in self.Memory:
            Memory_.export(outfile, level, namespace_, name_='Memory', pretty_print=pretty_print)
        for CachePowerModel_ in self.CachePowerModel:
            CachePowerModel_.export(outfile, level, namespace_, name_='CachePowerModel', pretty_print=pretty_print)
        for Cache_ in self.Cache:
            Cache_.export(outfile, level, namespace_, name_='Cache', pretty_print=pretty_print)
        for FifoPowerModel_ in self.FifoPowerModel:
            FifoPowerModel_.export(outfile, level, namespace_, name_='FifoPowerModel', pretty_print=pretty_print)
        for Fifo_ in self.Fifo:
            Fifo_.export(outfile, level, namespace_, name_='Fifo', pretty_print=pretty_print)
        for PhysicalLinkPowerModel_ in self.PhysicalLinkPowerModel:
            PhysicalLinkPowerModel_.export(outfile, level, namespace_, name_='PhysicalLinkPowerModel', pretty_print=pretty_print)
        for PhysicalLink_ in self.PhysicalLink:
            PhysicalLink_.export(outfile, level, namespace_, name_='PhysicalLink', pretty_print=pretty_print)
        for DMAControllerPowerModel_ in self.DMAControllerPowerModel:
            DMAControllerPowerModel_.export(outfile, level, namespace_, name_='DMAControllerPowerModel', pretty_print=pretty_print)
        for DMAController_ in self.DMAController:
            DMAController_.export(outfile, level, namespace_, name_='DMAController', pretty_print=pretty_print)
        for LogicalLink_ in self.LogicalLink:
            LogicalLink_.export(outfile, level, namespace_, name_='LogicalLink', pretty_print=pretty_print)
        for Communication_ in self.Communication:
            Communication_.export(outfile, level, namespace_, name_='Communication', pretty_print=pretty_print)
        for Peripheral_ in self.Peripheral:
            Peripheral_.export(outfile, level, namespace_, name_='Peripheral', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Subsystem':
            obj_ = SubsystemType.factory()
            obj_.build(child_)
            self.Subsystem.append(obj_)
            obj_.original_tagname_ = 'Subsystem'
        elif nodeName_ == 'VoltageDomain':
            obj_ = VoltageDomainType.factory()
            obj_.build(child_)
            self.VoltageDomain.append(obj_)
            obj_.original_tagname_ = 'VoltageDomain'
        elif nodeName_ == 'FrequencyDomain':
            obj_ = FrequencyDomainType.factory()
            obj_.build(child_)
            self.FrequencyDomain.append(obj_)
            obj_.original_tagname_ = 'FrequencyDomain'
        elif nodeName_ == 'SchedulingPolicyList':
            obj_ = SchedulingPolicyListType.factory()
            obj_.build(child_)
            self.SchedulingPolicyList.append(obj_)
            obj_.original_tagname_ = 'SchedulingPolicyList'
        elif nodeName_ == 'Scheduler':
            obj_ = SchedulerType.factory()
            obj_.build(child_)
            self.Scheduler.append(obj_)
            obj_.original_tagname_ = 'Scheduler'
        elif nodeName_ == 'ProcessorPowerModel':
            obj_ = ProcessorPowerModelType.factory()
            obj_.build(child_)
            self.ProcessorPowerModel.append(obj_)
            obj_.original_tagname_ = 'ProcessorPowerModel'
        elif nodeName_ == 'Processor':
            obj_ = ProcessorType.factory()
            obj_.build(child_)
            self.Processor.append(obj_)
            obj_.original_tagname_ = 'Processor'
        elif nodeName_ == 'MemoryPowerModel':
            obj_ = MemoryPowerModelType.factory()
            obj_.build(child_)
            self.MemoryPowerModel.append(obj_)
            obj_.original_tagname_ = 'MemoryPowerModel'
        elif nodeName_ == 'Memory':
            obj_ = MemoryType.factory()
            obj_.build(child_)
            self.Memory.append(obj_)
            obj_.original_tagname_ = 'Memory'
        elif nodeName_ == 'CachePowerModel':
            obj_ = CachePowerModelType.factory()
            obj_.build(child_)
            self.CachePowerModel.append(obj_)
            obj_.original_tagname_ = 'CachePowerModel'
        elif nodeName_ == 'Cache':
            obj_ = CacheType.factory()
            obj_.build(child_)
            self.Cache.append(obj_)
            obj_.original_tagname_ = 'Cache'
        elif nodeName_ == 'FifoPowerModel':
            obj_ = FifoPowerModelType.factory()
            obj_.build(child_)
            self.FifoPowerModel.append(obj_)
            obj_.original_tagname_ = 'FifoPowerModel'
        elif nodeName_ == 'Fifo':
            obj_ = FifoType.factory()
            obj_.build(child_)
            self.Fifo.append(obj_)
            obj_.original_tagname_ = 'Fifo'
        elif nodeName_ == 'PhysicalLinkPowerModel':
            obj_ = PhysicalLinkPowerModelType.factory()
            obj_.build(child_)
            self.PhysicalLinkPowerModel.append(obj_)
            obj_.original_tagname_ = 'PhysicalLinkPowerModel'
        elif nodeName_ == 'PhysicalLink':
            obj_ = PhysicalLinkType.factory()
            obj_.build(child_)
            self.PhysicalLink.append(obj_)
            obj_.original_tagname_ = 'PhysicalLink'
        elif nodeName_ == 'DMAControllerPowerModel':
            obj_ = DMAControllerPowerModelType.factory()
            obj_.build(child_)
            self.DMAControllerPowerModel.append(obj_)
            obj_.original_tagname_ = 'DMAControllerPowerModel'
        elif nodeName_ == 'DMAController':
            obj_ = DMAControllerType.factory()
            obj_.build(child_)
            self.DMAController.append(obj_)
            obj_.original_tagname_ = 'DMAController'
        elif nodeName_ == 'LogicalLink':
            obj_ = LogicalLinkType.factory()
            obj_.build(child_)
            self.LogicalLink.append(obj_)
            obj_.original_tagname_ = 'LogicalLink'
        elif nodeName_ == 'Communication':
            obj_ = CommunicationType.factory()
            obj_.build(child_)
            self.Communication.append(obj_)
            obj_.original_tagname_ = 'Communication'
        elif nodeName_ == 'Peripheral':
            obj_ = PeripheralType.factory()
            obj_.build(child_)
            self.Peripheral.append(obj_)
            obj_.original_tagname_ = 'Peripheral'
# end class SubsystemPlatformType


class SubsystemType(SubsystemPlatformType):
    subclass = None
    superclass = SubsystemPlatformType
    def __init__(self, Subsystem=None, VoltageDomain=None, FrequencyDomain=None, SchedulingPolicyList=None, Scheduler=None, ProcessorPowerModel=None, Processor=None, MemoryPowerModel=None, Memory=None, CachePowerModel=None, Cache=None, FifoPowerModel=None, Fifo=None, PhysicalLinkPowerModel=None, PhysicalLink=None, DMAControllerPowerModel=None, DMAController=None, LogicalLink=None, Communication=None, Peripheral=None, id=None):
        self.original_tagname_ = None
        super(SubsystemType, self).__init__(Subsystem, VoltageDomain, FrequencyDomain, SchedulingPolicyList, Scheduler, ProcessorPowerModel, Processor, MemoryPowerModel, Memory, CachePowerModel, Cache, FifoPowerModel, Fifo, PhysicalLinkPowerModel, PhysicalLink, DMAControllerPowerModel, DMAController, LogicalLink, Communication, Peripheral, )
        self.id = _cast(None, id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubsystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubsystemType.subclass:
            return SubsystemType.subclass(*args_, **kwargs_)
        else:
            return SubsystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_IdType(self, value):
        # Validate type IdType, a restriction on xs:ID.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_IdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IdType_patterns_, ))
    validate_IdType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (
            super(SubsystemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='SubsystemType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubsystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='SubsystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='SubsystemType'):
        super(SubsystemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubsystemType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='SubsystemType', fromsubclass_=False, pretty_print=True):
        super(SubsystemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_IdType(self.id)    # validate type IdType
        super(SubsystemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SubsystemType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SubsystemType


class PlatformType(SubsystemPlatformType):
    subclass = None
    superclass = SubsystemPlatformType
    def __init__(self, Subsystem=None, VoltageDomain=None, FrequencyDomain=None, SchedulingPolicyList=None, Scheduler=None, ProcessorPowerModel=None, Processor=None, MemoryPowerModel=None, Memory=None, CachePowerModel=None, Cache=None, FifoPowerModel=None, Fifo=None, PhysicalLinkPowerModel=None, PhysicalLink=None, DMAControllerPowerModel=None, DMAController=None, LogicalLink=None, Communication=None, Peripheral=None, version=None, generatorTarget=None):
        self.original_tagname_ = None
        super(PlatformType, self).__init__(Subsystem, VoltageDomain, FrequencyDomain, SchedulingPolicyList, Scheduler, ProcessorPowerModel, Processor, MemoryPowerModel, Memory, CachePowerModel, Cache, FifoPowerModel, Fifo, PhysicalLinkPowerModel, PhysicalLink, DMAControllerPowerModel, DMAController, LogicalLink, Communication, Peripheral, )
        self.version = _cast(None, version)
        self.generatorTarget = _cast(None, generatorTarget)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlatformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlatformType.subclass:
            return PlatformType.subclass(*args_, **kwargs_)
        else:
            return PlatformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_generatorTarget(self): return self.generatorTarget
    def set_generatorTarget(self, generatorTarget): self.generatorTarget = generatorTarget
    def validate_VersionType(self, value):
        # Validate type VersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_VersionType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_VersionType_patterns_, ))
    validate_VersionType_patterns_ = [['^[0-9.]+$']]
    def validate_NameType(self, value):
        # Validate type NameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NameType_patterns_, ))
    validate_NameType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (
            super(PlatformType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='PlatformType', namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='PlatformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='PlatformType'):
        super(PlatformType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformType')
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.generatorTarget is not None and 'generatorTarget' not in already_processed:
            already_processed.add('generatorTarget')
            outfile.write(' generatorTarget=%s' % (quote_attrib(self.generatorTarget), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='PlatformType', fromsubclass_=False, pretty_print=True):
        super(PlatformType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
            self.validate_VersionType(self.version)    # validate type VersionType
        value = find_attr_value_('generatorTarget', node)
        if value is not None and 'generatorTarget' not in already_processed:
            already_processed.add('generatorTarget')
            self.generatorTarget = value
            self.validate_NameType(self.generatorTarget)    # validate type NameType
        super(PlatformType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PlatformType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PlatformType


class FrequencyInputType(VoltageFrequencyDomainConditionListType):
    subclass = None
    superclass = VoltageFrequencyDomainConditionListType
    def __init__(self, VoltageDomainCondition=None, FrequencyDomainCondition=None, frequencyDomain=None, factor='1'):
        self.original_tagname_ = None
        super(FrequencyInputType, self).__init__(VoltageDomainCondition, FrequencyDomainCondition, )
        self.frequencyDomain = _cast(None, frequencyDomain)
        self.factor = _cast(None, factor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyInputType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyInputType.subclass:
            return FrequencyInputType.subclass(*args_, **kwargs_)
        else:
            return FrequencyInputType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frequencyDomain(self): return self.frequencyDomain
    def set_frequencyDomain(self, frequencyDomain): self.frequencyDomain = frequencyDomain
    def get_factor(self): return self.factor
    def set_factor(self, factor): self.factor = factor
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def validate_PositiveFloatType(self, value):
        # Validate type PositiveFloatType, a restriction on xs:double.
        if value is not None and Validate_simpletypes_:
            if value <= 0:
                warnings_.warn('Value "%(value)s" does not match xsd minExclusive restriction on PositiveFloatType' % {"value" : value} )
    def hasContent_(self):
        if (
            super(FrequencyInputType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FrequencyInputType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyInputType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FrequencyInputType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FrequencyInputType'):
        super(FrequencyInputType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyInputType')
        if self.frequencyDomain is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            outfile.write(' frequencyDomain=%s' % (quote_attrib(self.frequencyDomain), ))
        if self.factor != 1 and 'factor' not in already_processed:
            already_processed.add('factor')
            outfile.write(' factor=%s' % (quote_attrib(self.factor), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FrequencyInputType', fromsubclass_=False, pretty_print=True):
        super(FrequencyInputType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequencyDomain', node)
        if value is not None and 'frequencyDomain' not in already_processed:
            already_processed.add('frequencyDomain')
            self.frequencyDomain = value
            self.validate_RefType(self.frequencyDomain)    # validate type RefType
        value = find_attr_value_('factor', node)
        if value is not None and 'factor' not in already_processed:
            already_processed.add('factor')
            try:
                self.factor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (factor): %s' % exp)
            self.validate_PositiveFloatType(self.factor)    # validate type PositiveFloatType
        super(FrequencyInputType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FrequencyInputType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FrequencyInputType


class FrequencyType(VoltageFrequencyDomainConditionListType):
    subclass = None
    superclass = VoltageFrequencyDomainConditionListType
    def __init__(self, VoltageDomainCondition=None, FrequencyDomainCondition=None, value=None, unit=None):
        self.original_tagname_ = None
        super(FrequencyType, self).__init__(VoltageDomainCondition, FrequencyDomainCondition, )
        self.value = _cast(None, value)
        self.unit = _cast(None, unit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FrequencyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FrequencyType.subclass:
            return FrequencyType.subclass(*args_, **kwargs_)
        else:
            return FrequencyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def validate_FrequencyValueType(self, value):
        # Validate type FrequencyValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on FrequencyValueType' % {"value" : value} )
    def validate_FrequencyUnitType(self, value):
        # Validate type FrequencyUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Hz', 'kHz', 'MHz', 'GHz']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FrequencyUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(FrequencyType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='FrequencyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='FrequencyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='FrequencyType'):
        super(FrequencyType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FrequencyType')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='FrequencyType', fromsubclass_=False, pretty_print=True):
        super(FrequencyType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_FrequencyValueType(self.value)    # validate type FrequencyValueType
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_FrequencyUnitType(self.unit)    # validate type FrequencyUnitType
        super(FrequencyType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FrequencyType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FrequencyType


class VoltageInputType(VoltageFrequencyDomainConditionListType):
    subclass = None
    superclass = VoltageFrequencyDomainConditionListType
    def __init__(self, VoltageDomainCondition=None, FrequencyDomainCondition=None, voltageDomain=None):
        self.original_tagname_ = None
        super(VoltageInputType, self).__init__(VoltageDomainCondition, FrequencyDomainCondition, )
        self.voltageDomain = _cast(None, voltageDomain)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageInputType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageInputType.subclass:
            return VoltageInputType.subclass(*args_, **kwargs_)
        else:
            return VoltageInputType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_voltageDomain(self): return self.voltageDomain
    def set_voltageDomain(self, voltageDomain): self.voltageDomain = voltageDomain
    def validate_RefType(self, value):
        # Validate type RefType, a restriction on xs:IDREF.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_RefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RefType_patterns_, ))
    validate_RefType_patterns_ = [['^[a-zA-Z0-9_.]+$']]
    def hasContent_(self):
        if (
            super(VoltageInputType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='VoltageInputType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageInputType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='VoltageInputType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='VoltageInputType'):
        super(VoltageInputType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageInputType')
        if self.voltageDomain is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            outfile.write(' voltageDomain=%s' % (quote_attrib(self.voltageDomain), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='VoltageInputType', fromsubclass_=False, pretty_print=True):
        super(VoltageInputType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('voltageDomain', node)
        if value is not None and 'voltageDomain' not in already_processed:
            already_processed.add('voltageDomain')
            self.voltageDomain = value
            self.validate_RefType(self.voltageDomain)    # validate type RefType
        super(VoltageInputType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VoltageInputType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VoltageInputType


class VoltageType(VoltageFrequencyDomainConditionListType):
    subclass = None
    superclass = VoltageFrequencyDomainConditionListType
    def __init__(self, VoltageDomainCondition=None, FrequencyDomainCondition=None, value=None, unit=None):
        self.original_tagname_ = None
        super(VoltageType, self).__init__(VoltageDomainCondition, FrequencyDomainCondition, )
        self.value = _cast(None, value)
        self.unit = _cast(None, unit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageType.subclass:
            return VoltageType.subclass(*args_, **kwargs_)
        else:
            return VoltageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def validate_VoltageValueType(self, value):
        # Validate type VoltageValueType, a restriction on NonNegativeFloatType.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on VoltageValueType' % {"value" : value} )
    def validate_VoltageUnitType(self, value):
        # Validate type VoltageUnitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['mV', 'V']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoltageUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(VoltageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='slxplatform:', name_='VoltageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='slxplatform:', name_='VoltageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='slxplatform:', name_='VoltageType'):
        super(VoltageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageType')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='slxplatform:', name_='VoltageType', fromsubclass_=False, pretty_print=True):
        super(VoltageType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
            self.validate_VoltageValueType(self.value)    # validate type VoltageValueType
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_VoltageUnitType(self.unit)    # validate type VoltageUnitType
        super(VoltageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VoltageType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VoltageType


GDSClassesMapping = {
    'Active': CommunicationPhaseType,
    'Buffer': CommunicationBufferType,
    'Cache': CacheType,
    'CacheAccess': CacheAccessType,
    'CachePowerModel': CachePowerModelType,
    'CachePowerState': CachePowerStateType,
    'CacheRef': CacheRefType,
    'Communication': CommunicationType,
    'Consumer': CommunicationConsumerType,
    'DMAController': DMAControllerType,
    'DMAControllerPowerModel': DMAControllerPowerModelType,
    'DMAControllerPowerState': DMAControllerPowerStateType,
    'DMAControllerRef': DMAControllerRefType,
    'DataCacheRef': CacheRefType,
    'Fifo': FifoType,
    'FifoAccess': FifoAccessType,
    'FifoPowerModel': FifoPowerModelType,
    'FifoPowerState': FifoPowerStateType,
    'FifoRef': FifoRefType,
    'Frequency': FrequencyType,
    'FrequencyCondition': FrequencyConditionType,
    'FrequencyDomain': FrequencyDomainType,
    'FrequencyDomainCondition': FrequencyDomainConditionType,
    'FrequencyInput': FrequencyInputType,
    'FrequencyVoltageCondition': FrequencyVoltageConditionType,
    'InstructionCacheRef': CacheRefType,
    'LogicalLink': LogicalLinkType,
    'LogicalLinkRef': LogicalLinkRefType,
    'Memory': MemoryType,
    'MemoryAccess': MemoryAccessType,
    'MemoryPowerModel': MemoryPowerModelType,
    'MemoryPowerState': MemoryPowerStateType,
    'MemoryRef': MemoryRefType,
    'ParentCacheRef': CacheRefType,
    'ParentMemoryRef': MemoryRefType,
    'Passive': CommunicationPhaseType,
    'Peripheral': PeripheralType,
    'PeripheralEmulatorLibrary': PeripheralEmulatorLibraryType,
    'PhysicalLink': PhysicalLinkType,
    'PhysicalLinkPowerModel': PhysicalLinkPowerModelType,
    'PhysicalLinkPowerState': PhysicalLinkPowerStateType,
    'PhysicalLinkRef': PhysicalLinkRefType,
    'Platform': PlatformType,
    'Processor': ProcessorType,
    'ProcessorPowerModel': ProcessorPowerModelType,
    'ProcessorPowerState': ProcessorPowerStateType,
    'Producer': CommunicationProducerType,
    'Scheduler': SchedulerType,
    'SchedulingPolicy': SchedulingPolicyType,
    'SchedulingPolicyList': SchedulingPolicyListType,
    'Subsystem': SubsystemType,
    'Voltage': VoltageType,
    'VoltageCondition': VoltageConditionType,
    'VoltageDomain': VoltageDomainType,
    'VoltageDomainCondition': VoltageDomainConditionType,
    'VoltageInput': VoltageInputType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Platform'
        rootClass = PlatformType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoltageType'
        rootClass = VoltageType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoltageType'
        rootClass = VoltageType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:slxplatform="http://xsd.silexica.com/slxPlatform"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoltageType'
        rootClass = VoltageType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from platform import *\n\n')
        sys.stdout.write('import platform as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CacheAccessType",
    "CachePowerModelType",
    "CachePowerStateType",
    "CacheRefType",
    "CacheType",
    "CommunicationBufferType",
    "CommunicationConsumerType",
    "CommunicationPhaseType",
    "CommunicationProducerType",
    "CommunicationType",
    "DMAControllerPowerModelType",
    "DMAControllerPowerStateType",
    "DMAControllerRefType",
    "DMAControllerType",
    "FifoAccessType",
    "FifoPowerModelType",
    "FifoPowerStateType",
    "FifoRefType",
    "FifoType",
    "FrequencyConditionType",
    "FrequencyDomainConditionType",
    "FrequencyDomainType",
    "FrequencyInputType",
    "FrequencyType",
    "FrequencyVoltageConditionType",
    "LogicalLinkRefType",
    "LogicalLinkType",
    "MemoryAccessType",
    "MemoryPowerModelType",
    "MemoryPowerStateType",
    "MemoryRefType",
    "MemoryType",
    "PeripheralEmulatorLibraryType",
    "PeripheralType",
    "PhysicalLinkPowerModelType",
    "PhysicalLinkPowerStateType",
    "PhysicalLinkRefType",
    "PhysicalLinkType",
    "PlatformType",
    "ProcessorPowerModelType",
    "ProcessorPowerStateType",
    "ProcessorRefType",
    "ProcessorType",
    "SchedulerType",
    "SchedulingPolicyListType",
    "SchedulingPolicyType",
    "SubsystemPlatformType",
    "SubsystemType",
    "VoltageConditionType",
    "VoltageDomainConditionType",
    "VoltageDomainType",
    "VoltageFrequencyConditionListType",
    "VoltageFrequencyDomainConditionListType",
    "VoltageInputType",
    "VoltageType"
]
