# Copyright (C) 2019 TU Dresden
# Licensed under the ISC license (see LICENSE.txt)
#
# Authors: Felix Teweleit, Andres Goens

"""
This script contains helpful independent methods, which are needed for
functionality in other scripts of the platform package.
"""
import numpy as np
import logging

log = logging.getLogger(__name__)


def simpleDijkstra(adjacencyList, source, target):
    """
    This method performs the Dijkstra algorithm on simple graphs, given as an
    adjacency list.
    :param list[list[int] adjacencyList: A list where the indexes of elements in the outer list are
    equal to the index of the graph node. The integers in the inner list are equal to the indexes
    of graph nodes the outer node has an unweighted edge to.
    :param int source: The source node from which we want to determine the path.
    :param int target: The target node to which we want to determine the path.
    :returns: The list of nodes we need to visit to reach target from source.
    :rtype list[int]:
    """
    if isinstance(adjacencyList, dict):
        for element in adjacencyList:
            if not isinstance(adjacencyList[element], list):
                return None
    else:
        return None

    if adjacencyList[source] == []:
        return None

    distances = {}

    for node in adjacencyList:
        if not node == source:
            distances.update({node: None})
        else:
            distances.update({node: (0, [source])})

    visitedNodes = [source]
    currentPath = [source]
    currentNode = source

    while not currentNode == target:
        for reachable in adjacencyList[currentNode]:
            if distances[reachable] == None:
                distances.update(
                    {
                        reachable: (
                            distances[currentNode][0] + 1,
                            currentPath + [reachable],
                        )
                    }
                )
            if distances[currentNode][0] + 1 < distances[reachable][0]:
                distances.update(
                    {
                        reachable: (
                            distances[currentNode] + 1,
                            currentPath + [reachable],
                        )
                    }
                )

        nextNode = None
        for node in distances:
            if not distances[node] == None:
                if not node in visitedNodes and nextNode == None:
                    nextNode = node
                elif not node in visitedNodes:
                    if distances[node][0] < distances[nextNode][0]:
                        nextNode = node

        if nextNode == None:
            return None
        else:
            currentPath = distances[nextNode][1]
            currentNode = nextNode
            visitedNodes.append(nextNode)
    return currentPath


def valToXY(val, n):
    x = int(val % n)
    y = int(val / n)
    return x, y


def XYToVal(x, y, n):
    val = y * n + x
    return int(val)


def sign(x):
    if x < 0:
        return -1
    # also for 0, so that it works for the range
    elif x >= 0:
        return 1


def inclusive_range(start, stop, step):
    return range(start, (stop + 1) if step >= 0 else (stop - 1), step)


def yxRouting(adjacency_list, source, target):
    """
    This function implements Y-X routing.
    It assumes the topology is a mesh as generated by
    the meshTopology in mocasin.platform.topologies
    In particular, the adjacency list has to have a perfect
    square as the number of processors.
    """
    n = np.sqrt(len(adjacency_list))
    if int(n) != n:
        log.error(
            "Trying to calculate Y-X routing on an "
            "adjacency list that is not a square mesh."
        )
        raise RuntimeError
    if source == target:
        return [source]
    source_val = int(source.replace("processor_", ""))
    target_val = int(target.replace("processor_", ""))
    source_x, source_y = valToXY(source_val, n)
    target_x, target_y = valToXY(target_val, n)
    route = []
    range_y = inclusive_range(source_y, target_y, sign(target_y - source_y))
    range_x = inclusive_range(source_x, target_x, sign(target_x - source_x))

    for y in range_y:
        val = XYToVal(source_x, y, n)
        route.append(f"processor_{val:04d}")
    # do not count the value of the change of direction twice
    for x in range_x[1:]:
        val = XYToVal(x, target_y, n)
        route.append(f"processor_{val:04d}")

    # sanity check
    last_proc = source
    for proc in route[1:]:
        if proc not in adjacency_list[last_proc]:
            log.error(
                "Trying to calculate Y-X routing on an "
                "adjacency list that is not a square mesh."
            )
            raise RuntimeError
        last_proc = proc

    return route
